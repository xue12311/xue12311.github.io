<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flutter练习 - Future与FutureBuilder实例]]></title>
    <url>%2F2020%2F02%2F12%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Future%E4%B8%8EFutureBuilder%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[flutter练习 - Future与FutureBuilder实例 Future 异步操作 then ：异步操作逻辑 whenComplete ：异步完成时回调 catchError ：捕获异常或异步出错时的回调 timeout ：设置超时时间 Future的then的原型 1Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value),&#123;Function onError&#125;); onValue ：成功的结果回调 onError ：可选 ，执行出现异常 123456789101112131415161718import &apos;dart:async&apos;;Future&lt;String&gt; testFuture() &#123;// throw Error(); return Future.value(&quot;success&quot;);// return Future.error(&quot;error&quot;);&#125;//注意： 如果 catchError 与 onError 同时存在时，则只会调用 onErrorvoid main() &#123; testFuture().then((s) &#123; print(&quot;then : &quot; + s); &#125;, onError: (e) &#123; print(&quot;onError : &quot; + e); &#125;).whenComplete(() &#123; print(&quot;whenComplete&quot;); &#125;).catchError((e) &#123; print(&quot;catchError : &quot; + e); &#125;);&#125; 结合 async， await 123456789101112131415import &apos;dart:async&apos;;test() async &#123; String result = await Future.delayed(Duration(milliseconds: 2000), () &#123; return Future.value(&quot;success&quot;); &#125;); print(&quot;t3 : &quot; + DateTime.now().toString()); print(&quot;result : &quot; + result);&#125;main() &#123; test(); print(&quot;t1 : &quot; + DateTime.now().toString()); print(&quot;t2 : &quot; + DateTime.now().toString());&#125; future.timeout 设置超时时间 12345678910111213import &apos;dart:async&apos;;void main() &#123; Future.delayed(Duration(seconds: 2), () &#123; return &quot;success&quot;; &#125;).timeout(Duration(seconds: 1)).then((s) &#123; print(&quot;then : $s&quot;); &#125;).whenComplete(() &#123; print(&quot;whenComplete&quot;); &#125;).catchError((e) &#123; print(&quot;catchError : $e&quot;); &#125;);&#125; 代码运行会出现如下结果： 12whenCompletecatchError : TimeoutException after 0:00:01.000000: Future not completed FutureBuilder ---- 网络请求，数据库读取 更新 界面 FutureBuildere是一个将异步操作和异步UI更新结合在一起的类，通过它我们可以将网络请求，数据库读取等的结果更新到页面上 FutureBuilder的构造方法 1FutureBuilder(&#123;Key key,Future&lt;T&gt; future,T initialData,@required AsyncWidgetBuilder&lt;T&gt;builder&#125;); future ：Future对象表示此构造器当前连接的异步计算 initialData ：表示一个非空的Future完成前的初始化数据 builder ：AsyncWidgetBuilder类型返回的函数，是一个基于异步交互构建widget的函数 builder: BuildContext context AsyncSnapshot snapshot connectionState 表示与异步计算的连接状态 data - 异步计算接收的最新数据 error - 异步计算接收的最新错误对象； ConnectionState ：与异步计算的连接状态 none ：future还未执行的快照状态 waiting ：连接到一个异步操作，并且等待交互，一般在这种状态的时候，我们可以显示加载框 active ：连接到一个活跃的操作，比如stream流，会不断地返回值，并还没有结束，一般也是可以显示加载框 done：异步操作执行结束，一般在这里可以去拿取异步操作执行的结果，并显示相应的布局 ConnectionState 当前没有连接到任何的异步任务 ConnectionState.none 当前没有连接到任何的异步任务 ConnectionState.waiting 连接到异步任务并等待进行交互 ConnectionState.active 连接到异步任务并开始交互 ConnectionState.done 异步任务中止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import &apos;dart:convert&apos;;import &apos;package:flutter/material.dart&apos;;import &apos;package:http/http.dart&apos; as http;void main() =&gt; runApp(MyApp1());class MyApp1 extends StatefulWidget &#123; @override _MyApp1State createState() =&gt; _MyApp1State();&#125;class _MyApp1State extends State&lt;MyApp1&gt; &#123; String showResult = &apos;&apos;; Future&lt;CommonModel&gt; fetchPost() async &#123; final response = await http .get(&apos;http://www.devio.org/io/flutter_app/json/test_common_model.json&apos;); Utf8Decoder utf8decoder = Utf8Decoder(); //中文乱码// final result=json.decode(response.body); final result = json.decode(utf8decoder.convert(response.bodyBytes)); return CommonModel.fromJson(result); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( appBar: AppBar(title: Text(&apos;FutureBuilder&apos;)), body: FutureBuilder&lt;CommonModel&gt;( future: fetchPost(), builder: (BuildContext context, AsyncSnapshot&lt;CommonModel&gt; snapshot) &#123; switch (snapshot.connectionState) &#123; case ConnectionState.none: return new Text(&apos;Input a URL to start&apos;); case ConnectionState.waiting: return new Center(child: new CircularProgressIndicator()); case ConnectionState.active: return new Text(&apos;&apos;); case ConnectionState.done: if (snapshot.hasError) &#123; return new Text( &apos;$&#123;snapshot.error&#125;&apos;, style: TextStyle(color: Colors.red), ); &#125; else &#123; return new Column(children: &lt;Widget&gt;[ Text(&apos;icon:$&#123;snapshot.data.icon&#125;&apos;), Text(&apos;statusBarColor:$&#123;snapshot.data.statusBarColor&#125;&apos;), Text(&apos;title:$&#123;snapshot.data.title&#125;&apos;), Text(&apos;url:$&#123;snapshot.data.url&#125;&apos;) ]); &#125; &#125; &#125;, ), ), ); &#125;&#125;class CommonModel &#123; final String icon; final String title; final String url; final String statusBarColor; final bool hideAppBar; CommonModel( &#123;this.icon, this.title, this.url, this.statusBarColor, this.hideAppBar&#125;); factory CommonModel.fromJson(Map&lt;String, dynamic&gt; json) &#123; return CommonModel( icon: json[&apos;icon&apos;], title: json[&apos;title&apos;], url: json[&apos;url&apos;], statusBarColor: json[&apos;statusBarColor&apos;], hideAppBar: json[&apos;hideAppBar&apos;], ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Dart流程控制语句]]></title>
    <url>%2F2020%2F01%2F19%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Dart%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[flutter练习 - Dart流程控制语句 if 和 else 12345678void main() &#123; int x =10; if(x%2==0)&#123; print(&quot;$x 能被2整除&quot;); &#125;else&#123; print(&quot;$x 不能被2整除&quot;); &#125;&#125; for（循环） 1234567void main() &#123; var message = new StringBuffer(&quot;Hello Dart&quot;); for (var i = 0; i &lt; 10; i++) &#123; message.write(&quot;!&quot;); &#125; print(message);&#125; 123456void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var i = 0; i &lt; arr.length; i++) &#123; print(i); &#125;&#125; 1234567void main() &#123; var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; numbers.forEach((number) =&gt; print(number)); numbers.forEach((number) &#123; print(number); &#125;);&#125; while 和 do - while (循环) 1234567void main() &#123; var _temp = 0; while (_temp &lt; 5) &#123; print(&quot;这是一个while循环: $&#123;_temp.toString()&#125;&quot;); _temp++; &#125;&#125; 1234567void main() &#123; var _temp = 0; do &#123; print(&quot;这是一个while循环: $&#123;_temp.toString()&#125;&quot;); _temp++; &#125; while (_temp &lt; 5);&#125; break 和 continue 123456789void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var v in arr) &#123; if (v == 4) &#123; break;//跳出循环 &#125; print(v); &#125;&#125; 123456789void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var v in arr) &#123; if (v == 4) &#123; continue;//跳出本次循环 &#125; print(v); &#125;&#125; switch 和 case 1234567891011121314151617void main() &#123; var x = 10; switch (x % 3) &#123; case 0: print(&quot;余数: 0&quot;); break; case 1: print(&quot;余数: 1&quot;); break; case 2: print(&quot;余数: 2&quot;); break; default: print(&quot;其他&quot;); break; &#125;&#125; assert (断言) assert 语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在 Flutter 的调试模式下可以使用 assert。 如果assert条件为 false，则使用 assert 语句中断执行，并抛出一个断言错误异常AssertionError。 如果assert条件为 true，则继续执行下面的语句。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Dart常见运算符]]></title>
    <url>%2F2020%2F01%2F18%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Dart%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[flutter练习 - Dart常见运算符 算数运算符 操作符 含义 + 加 - 减 - expr 一元减号(负号) expr : 表达式的值 * 乘 / 除 ~/ 返回一个整数值的除法 % 取余数,除法剩下的余数 ++var var = var + 1 表达式的值为：var + 1 var++ var = var + 1 表达式的值为：var –var var = var - 1 表达式的值为：var - 1 var– var =var - 1 表达式的值为：var 关系运算符 操作符 含义 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 类型测试操作符 操作符 含义 as 类型转换 is 当对象是相应类型时返回 true is! 当对象不是相应类型时返回 true 赋值操作符 操作符 含义 a = value ; 将 value 赋值给 a b??= value ; 如果 b为空，则将value的值赋值给b，否则，b保持不变 a op b a = a op b a += b a = a + b a -= b a = a - b 逻辑运算符 操作符 含义 !expr 反转以下表达式( 将 false 更改为 true , 反之亦然) || 逻辑或 &amp;&amp; 逻辑与 位运算符 操作符 含义 &amp; 与 | 或 ^ 异或 -expr 一元位补码 ( 0s 变为 1s , 1s 变为 0s ) &lt;&lt; 左移 &gt;&gt; 右移 条件表达式 如果条件为真，返回 expr1,否则返回 expr2 。 condition ? expr1 : expr2 如果 expr1 为非空,则返回其值，否则 计算并返回 expr2 的值 expr1 ?? expr2 级联操作 级联操作符 (…) 可以在同一个对象上连续调用多个函数以及访问成员变量。使用级联操作符可以避免创建临时变量， 并且写出来的代码看起来更加流畅 1234querySelector(&apos;#button&apos;) // Get an object. ..text = &apos;Confirm&apos; // Use its members. ..classes.add(&apos;important&apos;) ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - Kotlin中的【 ?，?.，?:，!! ，filterNotNull 】含义]]></title>
    <url>%2F2020%2F01%2F05%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-KotlinfilterNotNull%20%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[kotlin练习 - Kotlin中的【 ?，?.，?:，!! ，filterNotNull 】含义 ? 可空类型，表示当前是否对象可以为空 12var a:String =&quot;123&quot;a = null //编译报错 12var a:String? =&quot;123&quot;a = null //编译通过 ?. 安全调用操作符 1234var a:String? =&quot;123&quot;a = null //编译通过val length = a.length //编译报错 --- 变量&quot;a&quot;可能会为空val length = a?.length //编译通过 --- 如果 a 非空，就返回 a.length，否则返回 null ?: Elvis 操作符 123var a:String? =&quot;123&quot;a = null //编译通过val lenght = a?.length?:-1 // 当a不为空时，返回a.length，当a为空时，返回-1 !! 操作符，表示当前对象不为空的情况下执行，为空就抛出异常 123var a:String? =&quot;123&quot;a = null //编译通过val lenght = a!!.length //如果a不为空，则返回a.length，如果b为空，则抛出异常 NullPointerException filterNotNull 过滤非空元素 123val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)val intList: List&lt;Int&gt; = nullableList.filterNotNull() println(intList.toString())//[1, 2, 4]]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 常见内联扩展函数学习]]></title>
    <url>%2F2019%2F07%2F21%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%B8%B8%E8%A7%81%E5%86%85%E8%81%94%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 常见内联扩展函数学习 let with apply run repeat also takeIf takeUnless kotlin练习 - 常见内联扩展函数学习 let 定义： fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R 功能： 调用对象（T）的let函数，则该对象为函数的参数。在函数内可以通过 it指代该对象。返回值为函数的最后一行或指定return表达式。 实例： 1234567891011fun main(args: Array&lt;String&gt;) &#123; val data = &quot;孙悟空&quot; data.let &#123; //在函数体内使用it替代object对象去访问其公有的属性和方法 println(it.toString()) &#125; data?.let &#123; // 假如data不为null，代码会执行到此处 println(it.toString()) &#125;&#125; with 定义： fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R 功能： 将对象作为函数的参数，在函数内可以通过this指代该对象。返回值为函数的最后一行或return表达式。 实例： 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; var list = with(mutableListOf&lt;String&gt;()) &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //返回值为函数的最后一行或return表达式 this &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123; var paint = Paint() with(paint) &#123; color = Color.BLACK strokeWidth = 1.0f textSize = 18.0f isAntiAlias = true &#125;&#125; apply 定义： fun T.apply(block: T.() -&gt; Unit): T 功能： 调用对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象。 实例： 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; // apply适用于那些对象初始化需要给其属性赋值的情况。 var list = mutableListOf&lt;String&gt;().apply &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //apply返回的是对象本身 &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123;//apply需要先初始化 var paint = Paint().apply &#123; color = Color.BLACK strokeWidth = 1.0f textSize = 18.0f isAntiAlias = true &#125;&#125; run 定义： fun run(block: () -&gt; R): R fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R 功能： 调用run函数返回值为函数体最后一行，或return表达式。 实例： 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;().run &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //run返回的是函数体最后一行，或return表达式 this &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123; var name = run &#123; &quot;孙悟空&quot; &#125; println(name)//孙悟空&#125; repeat 定义： fun repeat(times: Int, action: (Int) -&gt; Unit) 功能： 重复执行action函数times次，times从0开始 实例： 123456789101112fun main(args: Array&lt;String&gt;) &#123; repeat(3)&#123; //从0开始循环3次 println(&quot;repeat:第$&#123;it&#125;次&quot;) &#125; for(i in 0..2)&#123; println(&quot;for:第$&#123;i&#125;次&quot;) &#125; (0..2).forEach&#123; println(&quot;forEach:第$&#123;it&#125;次&quot;) &#125;&#125; also 定义： fun T.also(block: (T) -&gt; Unit): T 功能： 调用对象的also函数，在函数块内可以通过 it指代该对象,返回值为该对象本身。（注意其和let函数的区别，let返回的是最后一行，also返回的是对象本身） 实例： 12345678fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;().also &#123; it.add(&quot;1&quot;) it.add(&quot;2&quot;) it.add(&quot;3&quot;) &#125; println(list.toString())//[1, 2, 3]&#125; takeIf 定义： fun T.takeIf(predicate: (T) -&gt; Boolean): T? 功能： 传递一个函数参数，如果函数结果为true，返回T对象，否则返回null。 实例： 12345678910fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).takeIf &#123; it.size &gt; 3//满足条件则返回it,否则返回null &#125; if (list != null) &#123; println(list.toString()) &#125; else &#123; println(&quot;list为空&quot;) &#125;&#125; takeUnless 定义： fun T.takeUnless(predicate: (T) -&gt; Boolean): T? 功能： 与takeIf相反，参数函数返回false时返回T对象，否则返回null 实例： 12345678910fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).takeUnless &#123; it.size &gt; 3//不满足条件则返回it,否则返回null &#125; if (list != null) &#123; println(list.toString()) &#125; else &#123; println(&quot;list为空&quot;) &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus封装]]></title>
    <url>%2F2019%2F07%2F05%2Fandroid%2FEventBus%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[EventBus封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.eventbus.utilsimport com.example.gaokao.event.MessageEventimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.meta.SubscriberInfoIndex/** * * @author: xue * @description EventBus封装 * @date: 2019/7/5 */class EventBusUtil &#123; companion object &#123; /** * 使用索引加速 * 建议在Application中使用 */ fun installIndex(index: SubscriberInfoIndex) &#123; EventBus.builder().addIndex(index).installDefaultEventBus() &#125; /** * 注册 */ fun register(subscribe: Any) &#123; if (!EventBus.getDefault().isRegistered(subscribe)) &#123; EventBus.getDefault().register(subscribe) &#125; &#125; /** * 取消注册 */ fun unregister(subscribe: Any) &#123; EventBus.getDefault().unregister(subscribe) &#125; /** * 发布一个订阅事件 * 必须先注册，才能接收到发布的事件，有点类似于 startActivityForResult（）方法 */ fun postEvent(event: MessageEvent) &#123; EventBus.getDefault().post(event) &#125; /** * 发布粘性事件（可以先发布事件，在注册后在接收） * 粘性事件将最新的信息保存在内存中，取消原始消息，执行最新的消息； * 只有注册后，才能接收消息，如果没有注册，消息将保留在内存中。 */ fun postStickyEvent(event: MessageEvent) &#123; EventBus.getDefault().postSticky(event) &#125; /** * 移除指定的粘性订阅事件 * @param eventType 事件类型 */ fun &lt;T&gt; removeStickyEvent(eventType: Class&lt;T&gt;) &#123; var stickyEvent: T = EventBus.getDefault().getStickyEvent(eventType) if (stickyEvent != null) &#123; EventBus.getDefault().removeStickyEvent(stickyEvent) &#125; &#125; /** * 移除指定的粘性订阅事件 * @param eventType 事件类型 */ fun removeStickyEvent(eventType:Any) &#123; var stickyEvent = EventBus.getDefault().getStickyEvent(eventType as Class&lt;Any&gt;?) if (stickyEvent != null) &#123; EventBus.getDefault().removeStickyEvent(stickyEvent) &#125; &#125; /** * 移除所有的粘性订阅事件 */ fun removeAllStickyEvents()&#123; EventBus.getDefault().removeAllStickyEvents() &#125; /** * 取消事件 * 优先级高的订阅者可以终止事件往下传递 * 只有在事件通过时才能调用（即在事件接收方法中调用） * @param event 事件 */ fun cancelEventDelivery(event:Any)&#123; EventBus.getDefault().cancelEventDelivery(event) &#125; /** * 获取 eventbus 单例 */ fun getEventBus():EventBus&#123; return EventBus.getDefault() &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 协程]]></title>
    <url>%2F2019%2F06%2F30%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 协程 GlobalScope构造函数 launch : 创建协程 async : 创建带返回值的协程，返回 Deferred withContext : 不会创建新的协程，在指定协程上运行代码块 runBlocking : 不是GlobalScope的API，可以单独使用， runBlocking里面的delay()会堵塞当前线程，launch等不会堵塞 12345678910111213141516171819202122fun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch(Dispatchers.Main) &#123; LogUtils.d(&quot;当前线程main: $&#123;Thread.currentThread().name&#125; &quot;) withContextTest() &#125; //newSingleThreadContext 单线程 //newFixedThreadPoolContext 线程池 val singleThreadContext = newSingleThreadContext(&quot;single&quot;) GlobalScope.launch(singleThreadContext) &#123; LogUtils.d(&quot;当前线程_单线程: $&#123;Thread.currentThread().name&#125; &quot;)//single &#125; val fixedThreadPoolContext = newFixedThreadPoolContext(1, &quot;fixed&quot;) GlobalScope.launch(fixedThreadPoolContext) &#123; LogUtils.d(&quot;当前线程_线程池: $&#123;Thread.currentThread().name&#125; &quot;)//fixed &#125;&#125; suspend fun withContextTest() &#123; withContext(Dispatchers.IO) &#123; LogUtils.d(&quot;当前线程io: $&#123;Thread.currentThread().name&#125; &quot;) &#125; &#125; CoroutineContext协程运行的线程调度器 Dispatchers.Default : 默认（如果不写，默认就是Dispatchers.Default模式） Dispatchers.IO : IO线程 Dispatchers.Main : 主线程 Dispatchers.Unconfined : 没指定，就是在当前线程 CoroutineStart 启动模式 CoroutineStart.DEFAULT：默认（如果不写，默认就是CoroutineStart.DEFAULT模式） CoroutineStart.ATOMIC：自动（协程在开始执行之前不能被取消） CoroutineStart.UNDISPATCHED：立即执行协程 CoroutineStart.LAZY：懒加载 Job方法 job.start() : 启动协程，除了 lazy 模式，协程都不需要手动启动 job.join() : 等待协程执行完毕后再执行后面的代码块 job.cancel() : 取消一个协程 协程的取消有些特质，因为协程内部可以在创建协程的，这样的协程组织关系可以称为父协程,子协程： 父协程手动调用 cancel() 或者异常结束，会立即取消它的所有子协程 父协程必须等待所有子协程完成（处于完成或者取消状态）才能完成 子协程抛出未捕获的异常时，默认情况下会取消其父协程 job.cancelAndJoin() : 等待协程取消完毕后再执行后面的代码块 job.isActive : true - 处于活动状态 job.isCancelled : true - 已完成 job.isCompleted : true - 已取消 第一个协程程序 1234567891011121314import kotlinx.coroutines.GlobalScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchfun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch &#123;//在后台启动一个新的协程并继续 delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;我是kotlin&quot;) &#125; println(&quot;你好,&quot;)//协程已在等待时主线程还在继续 Thread.sleep(3000L)// 阻塞主线程 3 秒钟来保证 JVM 存活&#125; println(&quot;运行了吗？&quot;)&#125; 桥接阻塞与非阻塞的世界 12345678910111213141516import kotlinx.coroutines.*fun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch &#123; //在后台启动新的协程并继续 delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//协程已在等待时主线程还在继续 runBlocking &#123; //主线程 delay(3000L)//延迟 3 秒来保证 JVM 的存活 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;) &#125;&#125; 123456789101112import kotlinx.coroutines.*fun main() = runBlocking&lt;Unit&gt; &#123; //启动主协程 GlobalScope.launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 delay(3000L)// //延迟 3 秒以保持JVM活动 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;)&#125; 等待工作 12345678910111213import kotlinx.coroutines.*fun main() = runBlocking &#123; var job = GlobalScope.launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 job.join()//等到子协程完成后进行 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;)&#125; 结构化的并发 12345678910import kotlinx.coroutines.*fun main() = runBlocking &#123;launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;)&#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 &#125; 范围构建器 123456789101112131415161718import kotlinx.coroutines.*fun main() = runBlocking &#123; launch &#123; delay(200L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是Kotlin&quot;) &#125; coroutineScope &#123; launch &#123; delay(500L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你知道吗&quot;) &#125; delay(100L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)&#125; 提取函数重构 12345678910111213import kotlinx.coroutines.*fun main() = runBlocking &#123; launch &#123; doWorld() &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)&#125;suspend fun doWorld() &#123; delay(2000L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是Kotlin&quot;)&#125; 协同程序重量轻 12345678910import kotlinx.coroutines.*fun main() = runBlocking &#123; repeat(100_000)&#123; launch &#123; delay(1000L) println(&quot;.&quot;) &#125; &#125;&#125; 全局协程像守护线程 123456789101112import kotlinx.coroutines.*fun main() = runBlocking &#123; GlobalScope.launch &#123; repeat(1000) &#123; println(&quot;当前是第$&#123;(it + 1)&#125;个线程&quot;) delay(500L) &#125; &#125; delay(1300L)&#125; 协程请求网络数据 123456789101112131415161718class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) coroutine.setOnClickListener &#123; click() &#125; &#125; private fun click() = runBlocking &#123; GlobalScope.launch(Dispatchers.Main) &#123; coroutine.text = GlobalScope.async(Dispatchers.IO) &#123; // 比如进行了网络请求 // 放回了请求后的结构 return@async &quot;main&quot; &#125;.await() &#125; &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础-RxJava2学习]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid%2FRxJava2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文参考RxJava2 只看这一篇文章就够了，强烈推荐大家去看一下。 RxJava的组成 被观察者-------Observable 观察者-----------Observer 订阅---------------subscribe 1234567891011121314151617181920212223242526272829303132333435//被观察者 Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;a&quot;); emitter.onNext(&quot;b&quot;); emitter.onNext(&quot;c&quot;); emitter.onComplete(); &#125; &#125;); //观察者 Observer observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(s); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;; //订阅 observable.subscribe(observer); 创建操作符 create() 12345678//创建一个被观察者 Observable&lt;String&gt;observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;Hello Java&quot;); emitter.onComplete(); &#125; &#125;); just() --------发送事件不可以超过10个 123456Observable.just(1,2,3,4,5,6,7,8,9,0).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(integer); &#125; &#125;); From 操作符 fromArray() ----- 可以发送数组(数量可以大于10个) 1234567Integer integers[] = &#123;0,1,2,3,4,5&#125;; Observable.fromArray(integers).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(integer); &#125; &#125;); fromCallable() -----被观察者返回一个结果值给观察者 1234567891011Observable.fromCallable(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;hello&quot;; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); fromIterable() ---------可以发送一个List集合给观察者 123456789101112List&lt;String&gt;list = new ArrayList&lt;&gt;(); list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); list.add(&quot;5&quot;); Observable.fromIterable(list).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); fromFuture() ------- 可以发送一个Future 123456789101112131415161718FutureTask&lt;String&gt;futureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;Hello&quot;; &#125; &#125;); //doOnSubscribe()----- 开始订阅时才会执行 Observable.fromFuture(futureTask).doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; futureTask.run();//开始执行 &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); defer() -------------- 只有观察者订阅时，才会创建新的被观察者 1234567891011121314151617181920212223242526272829303132333435String str_name = &quot;张三&quot;; public void rxjava() &#123; Observable&lt;String&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends String&gt; call() throws Exception &#123; return Observable.just(str_name); &#125; &#125;); str_name = &quot;李四&quot;; Observer observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(&quot;str_name = &quot; + s);//王五，赵六 &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;; str_name = &quot;王五&quot;; observable.subscribe(observer); str_name = &quot;赵六&quot;; observable.subscribe(observer); &#125; timer() -------------当到了指定时间就发送一个0L的值给观察者 123456Observable.timer(2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;along : &quot;+aLong);//along : 0 &#125; &#125;); interval() ------------ 每隔一段时间就会发送一个事件（从0开始不断增加1的数字） 12345678910111213141516Observable.interval(2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 0， along : 1 &#125; &#125;); //延迟5s后开始执行 Observable.interval(5,2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 0， along : 1 &#125; &#125;); intervalRange() ------------ 可以指定发送事件的开始值，数量，其他的和interval()一样 1234567891011121314151617181920212223242526272829//start：起始数值 -------- 10//count：发射数量 -------- 3//initialDelay：延迟执行时间-------- 5s//period：发射周期时间------2s//unit：时间单位//数字从10开始，传递3次，第一次执行延迟5s，每隔2s执行一次Observable.intervalRange(10,3,5,2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 10， along : 11， along : 12 &#125;&#125;);//start：起始数值 -------- 10//count：发射数量 -------- 3//initialDelay：延迟执行时间-------- 5s//period：发射周期时间------2s//unit：时间单位//Scheduler：线程调度//数字从10开始，传递3次，第一次执行延迟5s，每隔2s执行一次，在新线程中执行Observable.intervalRange(10,3,5,2, TimeUnit.SECONDS, Schedulers.newThread()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;当前线程 ：&quot;+Thread.currentThread().getName());//RxNewThreadScheduler //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 10， along : 11， along : 12 &#125;&#125;); range() ----------- 发送一定范围内的事件 1234567//从10开始，执行3次 Observable.range(10,3).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;integer : &quot;+integer);//10,11,12 &#125; &#125;); rangeLong() ----和range()方法类似，只是数据类型为Long 1234567//从10开始，执行3次 Observable.rangeLong(10,3).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;along : &quot;+aLong);//10,11,12 &#125; &#125;); empty() &amp; never() &amp; error() empty() --------------- 直接发送 onComplete() 事件 12345678910111213141516171819//只会进入 onSubscribe(),onComplete()方法 Observable.empty().subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); never() ---------------- 不发生任何时间 12345678910111213141516171819//只会进入 onSubscribe()方法 Observable.never().subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); error() -------------------发送onError()事件 12345678910111213141516171819//只会进入 onSubscribe(),onError()方法 Observable.error(new NullPointerException()).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); 转换操作符 map() -------------- 将被观察者发送的数据类型转换成其他的类型 1234567891011Observable.just(1,2,3,4,5).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return &quot;当前值为：&quot;+integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); flatMap() ----------------- 作用于map() 方法类似，返回一个 新的Observerable (无序： flatMap()可能交错的发送事件,最终结果的顺序可能并是不原始Observable发送时的顺序 ) 1234567891011121314151617Observable.just(1, 2, 3, 4, 5).flatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;当前值为：&quot;+integer); if (integer == 3) &#123; return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);//延迟10毫秒 &#125; else &#123; return Observable.fromIterable(list); &#125; &#125; &#125;).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; LogUtils.e(o.toString());//当前值为：1,2,4,5,3 ------无序的 &#125; &#125;); concatMap() ------------ 作用和flatMap() 方法一样（有序：concatMap()转发事件的顺序是有序的） 1234567891011121314151617Observable.just(1, 2, 3, 4, 5).concatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;当前值为：&quot;+integer); if (integer == 3) &#123; return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);//延迟10毫秒 &#125; else &#123; return Observable.fromIterable(list); &#125; &#125; &#125;).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; LogUtils.e(o.toString());//当前值为：1,2,3,4,5, ------有序的 &#125; &#125;); buffer() ------------- 从需要发送的事件中获取一定数量的事件，将这些事件存放到缓冲区中一并发出 123456789101112131415//count: 缓冲区元素的数量//skip: 就代表缓冲区满了之后，发送下一次事件的时候要跳过的元素数量Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(List&lt;Integer&gt; integers) throws Exception &#123; LogUtils.e(&quot;缓冲区大小: &quot; + integers.size()); String str = &quot;&quot;; for (int i = 0; i &lt; integers.size(); i++) &#123; str = str + &quot;,&quot; + integers.get(i); &#125; LogUtils.e(&quot;当前元素: &quot; + str); &#125; &#125;); groupBy() ---------------- 将发送的数据进行分组，每个分组都会返回一个被观察者 12345678910111213141516171819Observable.just(1, 2, 3, 4, 5, 6, 7) .groupBy(new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer) throws Exception &#123; return integer % 2;//分为2组 &#125; &#125;) .subscribe(new Consumer&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void accept(GroupedObservable&lt;Integer, Integer&gt; integerIntegerGroupedObservable) throws Exception &#123; LogUtils.e(&quot; 第&quot; + integerIntegerGroupedObservable.getKey()+&quot;组&quot;); integerIntegerGroupedObservable.subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;第&quot; + integerIntegerGroupedObservable.getKey() + &quot;组，当前元素: &quot; + integer); &#125; &#125;); &#125; &#125;); scan() ---------------- 将数据按照一定的逻辑合并数据 1234567891011121314Observable.just(1, 2, 3, 4, 5, 6, 7) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer1, Integer integer2) throws Exception &#123; LogUtils.e(&quot;integer1 = &quot;+integer1);//上一次的结果 LogUtils.e(&quot;integer2 = &quot;+integer2); return integer1 +integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;integer1 + integer2 =&quot;+integer); &#125; &#125;); window() --------------将发送数据 按指定数量进行分组 12345678910111213Observable.just(1, 2, 3, 4, 5, 6, 7) .window(3) .subscribe(new Consumer&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void accept(Observable&lt;Integer&gt; integerObservable) throws Exception &#123; integerObservable.subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前元素: &quot; + integer); &#125; &#125;); &#125; &#125;); 组合操作符 zip() -------------- 将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。 12345678910111213141516171819202122232425262728Observable.zip( Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;), Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;), new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s, String s2) throws Exception &#123; String res = s + s2; LogUtils.d(&quot;A &amp; B 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.d( &quot;onNext: &quot; + s); &#125;&#125;); concat() -------------- 将多个观察者组合在一起，然后按照之前的发送顺序发送事件，最多只能合并4个被观察者 1234567891011Observable.concat( Observable.just(1,2), Observable.just(3,4), Observable.just(5,6), Observable.just(7,8) ).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前数字：&quot;+integer);//1,2,3,4,5,6,7,8 &#125; &#125;); concatArray() ------------ 作用和concat()方法一样，可以发送多于4个的被观察者 12345678910111213Observable.concatArray( Observable.just(1,2), Observable.just(3,4), Observable.just(5,6), Observable.just(7,8), Observable.just(9,10), Observable.just(11,12) ).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前数字：&quot;+integer);//1,2,3,4,5,6,7,8,9,10,11,12 &#125; &#125;); merge() -------------- 作用和concat() 方法一样，只不过concat()是串行发送，而merge() 是并行发送事件 123456789101112131415161718192021Observable.merge( Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long,String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;A&quot;+aLong; &#125; &#125;), Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long,String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;B&quot;+aLong; &#125; &#125;) ).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s);//A，B 交替出现---------- A0,B0,A1,B1,A2,B2 &#125; &#125;); combineLatest() ------------ 作用和zip()类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送。 12345678910111213141516171819202122232425262728Observable.combineLatest( Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;), Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;), new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s, String s2) throws Exception &#123; String res = s + s2; LogUtils.d(&quot;A &amp; B 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.d( &quot;onNext: &quot; + s); &#125;&#125;); concatArrayDelayError() &amp; mergeArrayDelayError()&amp; combineLatestDelayError() -------------- 如果有一个被观察者发送了一个Error事件，那么就结束发送，如果你想将Error() 事件延迟到所有被观察者都发送完事件后再执行。 1234567891011121314151617181920212223242526272829303132Observable.concatArrayDelayError( Observable.just(1,2), Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(3); e.onError(new NullPointerException()); e.onNext(4); &#125; &#125;), Observable.just(5,6) ).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.e(&quot;onNext : 当前数字：&quot;+integer);//1,2,3,5,6 &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError : &quot;+e.toString());//java.lang.NullPointerException &#125; @Override public void onComplete() &#123; &#125; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940Observable.mergeArrayDelayError( Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;A&quot; + aLong; &#125; &#125;), Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;C1&quot;); e.onNext(&quot;C2&quot;); e.onNext(&quot;C3&quot;); e.onError(new NullPointerException()); e.onNext(&quot;C4&quot;); e.onNext(&quot;C5&quot;); &#125; &#125;), Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;B&quot; + aLong; &#125; &#125;) ).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(s); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Observable&lt;String&gt; observable1 = Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;); Observable&lt;String&gt; observable3 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;C1&quot;); e.onNext(&quot;C2&quot;); e.onNext(&quot;C3&quot;); e.onError(new NullPointerException()); e.onNext(&quot;C4&quot;); e.onNext(&quot;C5&quot;); &#125; &#125;); Observable.combineLatestDelayError(new ObservableSource[]&#123;observable1, observable2, observable3&#125;, new Function() &#123; @Override public Object apply(Object o) throws Exception &#123; Object[] objects = (Object[]) o; String res = &quot;&quot;; for (int i = 0; i &lt; objects.length; i++) &#123; res = res + String.valueOf(objects[i]); &#125; LogUtils.d(&quot;A &amp; B &amp; C 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.d(s); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); reduce() ------------ 将所有数据聚合在一起才会发送事件给观察者 12345678910111213141516Observable.just(1,2,3,4,5,6,7,8) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer, Integer integer2) throws Exception &#123; int res = integer + integer2; LogUtils.d(&quot;integer : &quot; + integer); LogUtils.d(&quot;integer2 : &quot; + integer2); LogUtils.d(&quot;res : &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;accept : &quot;+ integer); &#125; &#125;); collect() ------------ 将数据收集到数据结构当中。 1234567891011121314151617Observable.just(1,2,3,4,5,6,7,8) .collect(new Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public ArrayList&lt;Integer&gt; call() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125; &#125;, new BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers, Integer integer) throws Exception &#123; integers.add(integer); &#125; &#125;).subscribe(new Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers) throws Exception &#123; LogUtils.d(integers); &#125; &#125;); startWith() &amp; startWithArray() ------------ 在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出 12345678910Observable.just(6, 7, 8) .startWithArray(3, 4, 5) .startWith(2) .startWithArray(0, 1) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(String.valueOf(integer)); &#125; &#125;); count() ------------ 返回被观察者发送事件的数量 12345678Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .count() .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.d(&quot;发送数量：&quot; + aLong);//8 &#125; &#125;); 功能操作符 delay() -------------- 延迟一段事件发送事件 12345678910111213141516171819202122Observable.just(1, 2, 3, 4) .delay(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnEach() ---------------- Observable 每发送一个之前都会先回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123; @Override public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception &#123; LogUtils.d(&quot;doOnEach 方法 &quot;+ integerNotification.getValue()); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnNext() ----------------- Observable 每发送 onNext() 之前都会先回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnNext(new Consumer&lt;Integer&gt;()&#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;doOnNext 方法 &quot;+ integer); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doAfterNext() -------------- Observable 每发送 onNext() 之后都会回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doAfterNext(new Consumer&lt;Integer&gt;()&#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;doAfterNext 方法 &quot;+ integer); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnComplete ------------------ Observable 每发送 onComplete() 之前都会回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnComplete 方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnError() ---------------- Observable 每发送 onError() 之前都会回调这个方法 12345678910111213141516171819202122232425262728293031323334353637Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .doOnError(new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;doOnError() :&quot;+throwable.toString()); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnSubscribe() ----------------- Observable 每发送 onSubscribe() 之前都会回调这个方法 12345678910111213141516171819202122232425262728293031323334353637Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125;&#125;) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; LogUtils.d(&quot;doOnSubscribe()方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnDispose() -------------- 当调用 Disposable 的取消订阅dispose()方法之后回调该方法 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if(integer==2)&#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnLifecycle() ------------- 在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnLifecycle(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; LogUtils.d(&quot;doOnLifecycle accept&quot;); //disposable.dispose();//取消订阅 &#125; &#125;, new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnLifecycle Action &quot;); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if (integer == 2) &#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnTerminate() &amp; doAfterTerminate() --------------- doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。如果取消订阅之后 doAfterTerminate() 就不会被回调 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnTerminate() 方法&quot;); &#125; &#125;) .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doAfterTerminate() 方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doFinally() ------------- 在所有事件发送完毕之后回调该方法，doFinally() 在取消订阅后也都会被回调，且都会在事件序列的最后。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doFinally(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doFinally() 方法&quot;); &#125; &#125;) .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doAfterTerminate() 方法&quot;); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if (integer == 2) &#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onErrorReturn() ------------------- 当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .onErrorReturn(new Function&lt;Throwable, Integer&gt;() &#123; @Override public Integer apply(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;onErrorReturn() 方法&quot;+throwable.toString()); return 404; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onErrorResumeNext() ----------- 当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;onErrorResumeNext()方法&quot;+throwable.toString()); return Observable.just(5,6,7,8,9); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onExceptionResumeNext() -------------- 与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception 12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new Exception(&quot;111&quot;)); &#125; &#125;) .onExceptionResumeNext(new Observable&lt;Integer&gt;() &#123; @Override protected void subscribeActual(Observer&lt;? super Integer&gt; observer) &#123; observer.onNext(404); observer.onNext(405); observer.onComplete(); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retry() ----------------- 如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数 123456789101112131415161718192021222324252627282930313233Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125;&#125;) .retry(2) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retryUntil() --------------- 出现错误事件之后，可以通过此方法判断是否继续发送事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445final int[] i = &#123;0&#125;; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); e.onError(new NullPointerException()); &#125; &#125;) .retryUntil(new BooleanSupplier() &#123; @Override public boolean getAsBoolean() throws Exception &#123; if (i[0] &gt;= 6) &#123;//停止继续发送 return true; &#125; else &#123; return false; &#125; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; i[0] += integer; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retryWhen() ---------------- 当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); e.onError(new NullPointerException()); &#125; &#125;) .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; if (throwable instanceof NullPointerException)&#123; return Observable.error(new Throwable(&quot;终止啦&quot;)); &#125;else&#123; return Observable.just(6,7,8,9); &#125; &#125; &#125;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); repeat() -------------- 重复发送被观察者的事件，times 为发送次数 12345678910111213141516171819202122232425262728293031323334Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .repeat(2) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); repeatWhen() ------------------ 这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123; return Observable.empty();//直接发送 onComplete() 事件// return Observable.just(1);//不发送任何事件// return Observable.error(new Exception(&quot;404&quot;));//发送 onError() 事件 &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); subscribeOn() ------------ 指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtils.d(&quot;当前线程：&quot;+Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.newThread()) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); LogUtils.d(&quot;onSubscribe()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); LogUtils.d(&quot;onNext()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); LogUtils.d(&quot;onError()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); LogUtils.d(&quot;onComplete()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; &#125;); observeOn() ----------------- 指定观察者的线程，每指定一次就会生效一次 12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtils.d(&quot;当前线程：&quot;+Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); LogUtils.d(&quot;onSubscribe()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); LogUtils.d(&quot;onNext()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); LogUtils.d(&quot;onError()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); LogUtils.d(&quot;onComplete()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; &#125;); 过滤操作符 filter() -------------- 通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送 123456789101112131415161718192021222324252627282930313233Observable.just(1, 2, 3, 4, 5, 6) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; if (integer % 2 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); ofType() ----------------- 可以过滤不符合该类型事件 123456789101112131415161718192021222324Observable.just(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,1,2,3) .ofType(Integer.class) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); skip() &amp; skipLast() --------------- 跳过正序某些事件，count 代表跳过事件的数量 12345678910111213141516171819202122232425Observable.just(1,2,3,4,5,6) .skip(2)//跳过前面2个事件 .skipLast(2)//跳过后面2个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); distinct() ------------ 过滤事件序列中的重复事件 123456789101112131415161718192021222324Observable.just(1,2,3,4,4,3,2,1) .distinct() .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer);//1,2,3,4 &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); distinctUntilChanged() ---------------- 过滤掉连续重复的事件 123456789101112131415161718192021222324Observable.just(1,2,3,4,4,3,2,1) .distinctUntilChanged() .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer);//1，2，3，4，3，2，1 &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); take() &amp; takeLast() --------------------- 控制观察者接收的事件的数量 12345678910111213141516171819202122232425Observable.just(1,2,3,4,5,6,7,8,9) .take(3)//只接收前面3个// .takeLast(2)//只接收后面2个 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); debounce() ----------------- 如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者 12345678910111213141516171819202122232425262728293031Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); Thread.sleep(900); e.onNext(2); &#125; &#125;) .debounce(1,TimeUnit.SECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); firstElement() &amp;&amp; lastElement() ----------------- firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素 12345678910111213141516Observable.just(1, 2, 3, 4) .firstElement() .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;firstElement() 方法 &quot; + integer); &#125; &#125;); Observable.just(1, 2, 3, 4) .lastElement() .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;lastElement() 方法 &quot; + integer); &#125; &#125;); elementAt() &amp; elementAtOrError() -------------- elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 123456789101112131415161718Observable.just(1, 2, 3, 4) .elementAt(4) .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;elementAt() 方法 &quot; + integer); &#125; &#125;); Observable.just(1, 2, 3, 4) .elementAtOrError(4)//报错 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;elementAtOrError() 方法 &quot; + integer); &#125; &#125;); 条件操作符 all() ---------------- 判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false 123456789101112Observable.just(1, 2, 3, 4) .all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 5; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); takeWhile() ------------- 可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .takeWhile(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 4;//如果第一条数据没有满足条件，后面的都不会进行 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;); skipWhile() ---------- 可以设置条件，当某个数据满足条件时不发送该数据，反之则发送 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .skipWhile(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 4;//当满足条件时，后面的都运行 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125;&#125;); takeUntil() -------------- 可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .takeUntil(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &gt;= 3;//当满足条件后，从下一次的事件开始都不会发送了 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;); skipUntil() ------------ 当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者 123456789101112131415161718192021222324Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS) .skipUntil(Observable.intervalRange(1, 3, 2, 1, TimeUnit.SECONDS)) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Long along) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + along); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); sequenceEqual() --------------- 判断两个 Observable 发送的事件是否相同 1234567Observable.sequenceEqual(Observable.just(1, 2, 3), Observable.just(1, 2, 3)) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); contains() ------------- 判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false 12345678Observable.just(1,2,3,4,5) .contains(3) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); isEmpty() --------------- 判断事件序列是否为空 ( true ：空 ) 12345678910111213Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onComplete(); &#125; &#125;) .isEmpty() .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); amb() --------------- amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃 123456789101112131415161718192021222324252627List&lt;Observable&lt;Long&gt;&gt; list = new ArrayList&lt;&gt;();list.add(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS));list.add(Observable.intervalRange(11, 5, 0, 1, TimeUnit.SECONDS));list.add(Observable.intervalRange(21, 5, 2, 1, TimeUnit.SECONDS));Observable.amb(list) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Long along) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + along); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); defaultIfEmpty() -------------- 如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值 12345678910111213Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onComplete(); &#125; &#125;) .defaultIfEmpty(1001) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>rxjava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 集合练习]]></title>
    <url>%2F2019%2F03%2F14%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 集合练习 Set集合 Set集合创建 12345678910111213141516171819202122232425fun main(args: Array&lt;String&gt;) &#123; //创建不可变集合，返回Set var set = setOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(set)//[java, kotlin, go] println(&quot;setOf 返回类型 $&#123;set.javaClass&#125;&quot;) //创建可变集合，返回值MutableSet var mutablemap = mutableListOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) mutablemap[0] = &quot;JavaScript&quot; println(mutablemap)//[JavaScript, kotlin, go] println(&quot;mutableListOf 返回类型 $&#123;mutablemap.javaClass&#125;&quot;) //创建LinkedHashSet集合 var linkedHashSet = linkedSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(linkedHashSet) println(&quot;linkedHashSet 返回类型 $&#123;linkedHashSet.javaClass&#125;&quot;) //创建HashSet集合 var hashSet = hashSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(hashSet)//不保证元素的顺序--[kotlin, go, java] //创建TreeSet集合 var treeSet = sortedSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(treeSet)//集合按从小到大排列--[go, java, kotlin]&#125; Set集合的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//创建不可变集合，返回Set var set = setOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) //判断是否所有的元素长度都大于5 ------所有元素都满足条件 println(set.all &#123; it.length &gt; 5 &#125;)// false //判断是否任意一元素的长度大于5 ------任意元素都满足条件 println(set.any &#123; it.length &gt; 5 &#125;)//true //以Lambda 表达式的值为key , 集合元素为value ,组成的Map集合 var map = set.associateBy(&#123; &quot;我正在学习$&#123;it&#125;&quot; &#125;) println(map)//&#123;我正在学习java=java, 我正在学习kotlin=kotlin, 我正在学习go=go&#125; //使用in、!in运算符 println(&quot;java&quot; in set)// true println(&quot;java&quot; !in set)// false //删除Set集合前面两个元素 var dropedList = set.drop(2) println(dropedList)// [go] //对Set集合进行过滤: 需要得到所有包含 va 的集合, var filteredList1 = set.filter(&#123; &quot;va&quot; in it &#125;)//如果没有返回空元素的集合 println(filteredList1)//[java] //查找Set集合中包含 va 的元素，如果找到就返回该元素，否则返回 null var filteredList2 = set.find(&#123; &quot;o&quot; in it &#125;) println(filteredList2)//kotlin var filteredList3 = set.find(&#123; &quot;va1&quot; in it &#125;) println(filteredList3)//null //将Set集合中所有字符串拼接在一起 var foldedList1 = set.fold(&quot;&quot;, &#123; acc, s -&gt; acc + s &#125;) println(foldedList1)//javakotlingo var foldedList2 = set.fold(&quot;456&quot;, &#123; acc, s -&gt; acc +&quot; 123 $&#123;s&#125;&quot; &#125;) println(foldedList2)//456 123 java 123 kotlin 123 go //查找某个元素的出现位置------没有就会返回-1 println(set.indexOf(&quot;kotlin&quot;))// 1 println(set.indexOf(&quot;kotlin1&quot;))// -1 //循环遍历 var books = setOf(&quot;疯狂java讲义&quot;, &quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;, &quot;疯狂android讲义&quot;) for (book in books)&#123; println(book) &#125; books.forEach(&#123; println(it) &#125;) for (i in books.indices)&#123; println(books.elementAt(i)) &#125; var books = mutableSetOf(&quot;疯狂java讲义&quot;) //新增 books.addAll(setOf(&quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;)) books.add(&quot;疯狂android讲义&quot;) println(books.toString())//[疯狂java讲义, 疯狂kotlin讲义, 疯狂IOS讲义, 疯狂android讲义] //删除 books.remove(&quot;疯狂kotlin讲义&quot;) println(books.toString())//[疯狂java讲义,疯狂IOS讲义, 疯狂android讲义] books.removeAll(setOf(&quot;疯狂java讲义&quot;)) println(books.toString())//[疯狂IOS讲义, 疯狂android讲义] //清空所有 books.clear() println(books.toString())//[] //只保留公共的元素 books = mutableSetOf(&quot;疯狂java讲义&quot;, &quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;, &quot;疯狂android讲义&quot;) books.retainAll(setOf(&quot;疯狂kotlin讲义&quot;, &quot;疯狂PHP讲义&quot;, &quot;疯狂android讲义&quot;)) println(books.toString())//[疯狂kotlin讲义, 疯狂android讲义] List集合 List集合创建 1234567891011121314var list1 = listOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list1.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] var list2 = listOfNotNull(1, 2, 3, 4, 5, null, 7, 8, 9) println(list2.toString())//[1, 2, 3, 4, 5, 7, 8, 9] var list3 = mutableListOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list3.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] list3.add(10) list3.set(5, 6) println(list3.toString())//[1, 2, 3, 4, 5, 6, 7, 8, 9,10] var list4 = arrayListOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list4.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] list4.set(5, 6) list4.add(10) println(list4.toString())//[1, 2, 3, 4, 5, 6, 7, 8, 9,10] List集合的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //遍历List var list1 = listOf(&quot;Java&quot;, null, &quot;Kotlin&quot;, &quot;Go&quot;) list1.forEach &#123; println(it) &#125; for (str in list1) &#123; println(str) &#125; for (i in list1.indices) &#123; println(list1[i]) println(&quot;get = $&#123;list1.get(i)&#125;&quot;) println(&quot;elementAt = $&#123;list1.elementAt(i)&#125;&quot;) &#125; var index = list1.indexOf(&quot;Go&quot;) println(&quot;Go 在数组中的位置：$&#123;index&#125;&quot;)//3 var list2 = mutableListOf(1, 2, 3, 1, 8, 3, 4, 6, 1, 4, 2, 3) //最后一次出现的的位置 var last1 = list2.lastIndexOf(2)//10 //最后一次出现的的位置 var last2 = list2.indexOfLast &#123; it == 2 &#125;//10 //第一次出现的位置 var first = list2.indexOfFirst &#123; it == 2 &#125;//1 println(&quot;2在数组中第一次出现在$&#123;first&#125;,最后一次出现在$&#123;last1&#125;,$&#123;last2&#125;&quot;) //返回集合 var list3 = listOf(&quot;Java&quot;, null, &quot;Kotlin&quot;, &quot;PHP&quot;, null, &quot;Go&quot;) var sublist = list3.subList(2, 5)//从第2个到第5个之间的元素 println(sublist.toString())//[Kotlin, PHP, null]// var list4 = mutableListOf(&quot;Java&quot;, &quot;JavaScript&quot;, null, &quot;HTML&quot;, &quot;Kotlin&quot;, null, &quot;Python&quot;, &quot;PHP&quot;, &quot;Go&quot;) var list4 = mutableListOf(&quot;Java&quot;, null, &quot;HTML&quot;, &quot;Go&quot;) println(list4)//[Java, null, HTML, Go] //新增 list4.add(&quot;Python&quot;) list4.add(2, &quot;C++&quot;) list4.addAll(listOf(&quot;Kotlin&quot;, null)) println(list4)//[Java, null, C++, HTML, Go, Python, Kotlin, null] //删除 list4.removeAt(1) println(list4)//[Java, C++, HTML, Go, Python, Kotlin, null] //list4[6] =&quot;CSS&quot;; list4.set(6, &quot;CSS&quot;) println(list4)//[Java, C++, HTML, Go, Python, Kotlin, CSS] list4.remove(&quot;Go&quot;) println(list4)//[Java, C++, HTML, Python, Kotlin, CSS] list4.add(3, &quot;Go&quot;) list4.add(5, &quot;Go&quot;) println(list4)//[Java, C++, HTML, Go, Python, Go, Kotlin, CSS] //替换元素 list4.replaceAll &#123; if (it.equals(&quot;Go&quot;)) &#123; &quot;go&quot; &#125; else &#123; it &#125; &#125; println(list4)//[Java, C++, HTML, go, Python, go, Kotlin, CSS] //删除 list4.removeAll(listOf(&quot;go&quot;)) println(list4)//[Java, C++, HTML, Python, Kotlin, CSS] //清空 list4.clear() println(list4)//[] Map集合 Map集合创建 12345678910111213141516171819//不可变map集合var map1 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map1)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//可变集合MutableMapvar map2 = mutableMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map2)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;map2.put(&quot;Python&quot;, 5)println(map2)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=5&#125;map2.remove(&quot;JavaScript&quot;)println(map2)//&#123;Java=1, HTML=3, Kotlin=4, Python=5&#125;//HashMap集合----不保证key-value的顺序var map3 = hashMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map3)//&#123;Java=1, HTML=3, JavaScript=2, Kotlin=4&#125;//LinkedHashMap集合---key-value按添加顺序排列var map4 = linkedMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map4)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//SortedMap集合------ key-value按key由小到大排列var map5 = sortedMapOf(&quot;Java&quot; to 1, &quot;Python&quot; to 5, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;JavaScript&quot; to 2, &quot;Go&quot; to 6)println(map5)//&#123;Go=6, HTML=3, Java=1, JavaScript=2, Kotlin=4, Python=5&#125; Map集合的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var map1 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)//当map集合中所有key-value对都满足条件返回truevar all = map1.all &#123; it.key.length &gt;= 4 &amp;&amp; it.value &gt; 0&#125;println(all)//true//当map集合中任意一个key-value对满足条件就会返回truevar any = map1.any &#123; it.key.length &gt;= 10 &amp;&amp; it.value &gt; 1&#125;println(any)//true//判断map集合中是否有对于key的key-valueprintln(&quot;Java&quot; in map1);//trueprintln(&quot;Java&quot; !in map1);//falseprintln(&quot;Go&quot; in map1);//falseprintln(&quot;Go&quot; !in map1);//true//对map进行过滤，要求key中包含：Javavar filterMap1 = map1.filter &#123; &quot;Java&quot; in it.key &#125;println(filterMap1)//&#123;Java=1, JavaScript=2&#125;var filterMap2 = map1.filter &#123; it.key in &quot;Java&quot; &#125;println(filterMap2)//&#123;Java=1&#125;//通过map集合，返回一个新的Listvar mappedList1 = map1.map &#123; &quot;《疯狂$&#123;it.key&#125;》讲义,第$&#123;it.value&#125;个&quot; &#125;var mappedList2 = map1.map &#123; &quot;《疯狂$&#123;it.key&#125;》讲义&quot; to &quot;第$&#123;it.value&#125;个&quot; &#125;println(mappedList1)//[《疯狂Java》讲义,第1个, 《疯狂JavaScript》讲义,第2个, 《疯狂HTML》讲义,第3个, 《疯狂Kotlin》讲义,第4个]println(mappedList2)//[(《疯狂Java》讲义, 第1个), (《疯狂JavaScript》讲义, 第2个), (《疯狂HTML》讲义, 第3个), (《疯狂Kotlin》讲义, 第4个)]//Map集合中key-value对中 value最大的值var maxby1 = map1.maxBy &#123; it.value &#125;println(maxby1)//Kotlin=4//Map集合中key-value对中 value最小的值var minby1 = map1.minBy &#123; it.value &#125;println(minby1)//Java=1//Map集合中key-value对中 key的长度最大的值var maxby2 = map1.maxBy &#123; it.key.length &#125;println(maxby2)//JavaScript=2//Map集合中key-value对中 key的长度最小的值var minby2 = map1.minBy &#123; it.key.length &#125;println(minby2)//Java=1var map2 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)var map3 = mapOf(&quot;Python&quot; to 1, &quot;Go&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)//集合相加---相当于并集println(map2 + map3)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=1, Go=2&#125;//集合相减---减去公共的元素println(map2 - map3)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;var plus = map2.plus(map3)println(plus)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=1, Go=2&#125;var minus = map2.minus(map3)println(minus)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//遍历Map集合var map4 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;Go&quot; to 5)for (en in map4.entries) &#123; println(&quot;$&#123;en.key&#125; -&gt; $&#123;en.value&#125;&quot;)&#125;for (key in map4.keys) &#123; println(&quot;$&#123;key&#125; -&gt; $&#123;map4[key]&#125;&quot;)&#125;for ((key, value) in map4) &#123; println(&quot;$&#123;key&#125; -&gt; $&#123;value&#125;&quot;)&#125;map4.forEach(&#123; println(&quot;$&#123;it.key&#125; -&gt; $&#123;it.value&#125;&quot;)&#125;)var map5 = mutableMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;Go&quot; to 5)map5[&quot;Go&quot;] = 0println(map5)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Go=0&#125;map5.put(&quot;HTML&quot;, 10)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4, Go=0&#125;map5.remove(&quot;Go&quot;)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4&#125;map5.remove(&quot;Java&quot;, 2)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4&#125;map5.remove(&quot;Java&quot;, 1)println(map5)//&#123;JavaScript=2, HTML=10, Kotlin=4&#125;map5.putAll(hashMapOf(&quot;PHP&quot; to 6, &quot;C++&quot; to 7,&quot;JavaScript&quot; to 8 ))println(map5)//&#123;JavaScript=8, HTML=10, Kotlin=4, PHP=6, C++=7&#125;//清空Map集合map5.clear()println(map5)//&#123;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView 图片选择]]></title>
    <url>%2F2019%2F01%2F20%2Fandroid%2FWebView%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[WebView 图片选择 最近需要做webview选择图片，就找了一些资料，记录一下。 本文参考:Android使用WebView从相册/拍照中添加图片 自定义WebChromeClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344import android.net.Uri;import android.webkit.ValueCallback;import android.webkit.WebChromeClient;import android.webkit.WebView;/** * WebView 上传文件 */public class ReWebChomeClient extends WebChromeClient &#123; private OpenFileChooserCallBack mOpenFileChooserCallBack; public ReWebChomeClient(OpenFileChooserCallBack openFileChooserCallBack) &#123; mOpenFileChooserCallBack = openFileChooserCallBack; &#125; //For Android 3.0+ public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; mOpenFileChooserCallBack.openFileChooserCallBack(uploadMsg, acceptType); &#125; // For Android &lt; 3.0 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openFileChooser(uploadMsg, &quot;&quot;); &#125; // For Android &gt; 4.1.1 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openFileChooser(uploadMsg, acceptType); &#125; // For Android 5.0+ @Override public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) &#123; mOpenFileChooserCallBack.showFileChooserCallBack(filePathCallback); return true; &#125; public interface OpenFileChooserCallBack &#123; void openFileChooserCallBack(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType); void showFileChooserCallBack(ValueCallback&lt;Uri[]&gt; filePathCallback); &#125;&#125; 使用ReWebChomeClient 1234567891011121314151617181920212223242526272829//定义变量private ValueCallback&lt;Uri&gt; uploadMessage;private ValueCallback&lt;Uri[]&gt; uploadMessageAboveL;//用来判断是否需要给WebView返回nullprivate int web_image = 0;private String picFilePath;//图片保存路径private int IDENTITY_IMAGE_REQUEST_CODE_Album = 1;//相册private int IDENTITY_IMAGE_REQUEST_CODE_Photograph = 2;// 拍照private int FILE_CHOOSER_RESULT_CODE = 3;//图片选择...//设置WebChromeClientmWebView.setWebChromeClient(mWebChromeClient);...private ReWebChomeClient mWebChromeClient = new ReWebChomeClient(new ReWebChomeClient.OpenFileChooserCallBack() &#123; @Override public void openFileChooserCallBack(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123;//Android &gt;=3.0 uploadMessage = uploadMsg; openImageChooserActivity(); &#125; @Override public void showFileChooserCallBack(ValueCallback&lt;Uri[]&gt; filePathCallback) &#123;// Android &gt;= 5.0 uploadMessageAboveL = filePathCallback; openImageChooserActivity(); &#125; &#125;); 选择图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 private void openImageChooserActivity() &#123; web_image = 0;//判断是否已经选择了 //自定义选择图片提示框 AlertDialog dialog = new AlertDialog.Builder(mContext).setItems(R.array.head_type_array, (dialog1, which) -&gt; &#123; //如果点击了dialog的选项，修改变量，不要在setOnDismissListener()方法中 web_image = 1; selected(which); &#125;).create(); dialog.show(); dialog.setOnDismissListener(dialog12 -&gt; &#123; if (web_image == 0) &#123; getImageWebView(null); &#125; &#125;); &#125; public void selected(int position) &#123; switch (position) &#123; case 0://相册 getPermissionsStorage(); break; case 1:// 拍照 getPermissionsCamera(); break; case 2://选择图片 Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); i.setType(&quot;image/*&quot;); startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILE_CHOOSER_RESULT_CODE); break; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == IDENTITY_IMAGE_REQUEST_CODE_Photograph) &#123;//拍照 if (resultCode == Activity.RESULT_OK) &#123; // 添加图片 if (picFilePath == null) &#123; picFilePath = Datas.picPathSD + BitmapUtil.pictime; &#125; getImageWebView(picFilePath); &#125; else &#123; // 删除图片 BitmapUtil.deleteTempFile(picFilePath); getImageWebView(null); &#125; &#125; else if (requestCode == IDENTITY_IMAGE_REQUEST_CODE_Album) &#123;//相册 if (resultCode == 1020) &#123; String str_images = StringUtils.null2Length0(data.getStringExtra(&quot;images&quot;)); getImageWebView(str_images); &#125; else &#123; getImageWebView(null); &#125; &#125; else if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;//选择图片 if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) &#123; return; &#125; Uri result = data == null || resultCode != RESULT_OK ? null : data.getData(); if (uploadMessageAboveL != null) &#123; onActivityResultAboveL(requestCode, resultCode, data); &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(result); &#125; &#125; &#125; private void getImageWebView(String str_image) &#123;//将图片路径返回给webview if (!StringUtils.isEmpty(str_image)) &#123; Uri uri = getImageContentUri(mContext, new File(str_image)); if (uploadMessageAboveL != null) &#123; Uri[] uris = new Uri[]&#123;uri&#125;; uploadMessageAboveL.onReceiveValue(uris); uploadMessageAboveL = null; &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(uri); uploadMessage = null; &#125; &#125; else &#123; if (uploadMessageAboveL != null) &#123; uploadMessageAboveL.onReceiveValue(null); uploadMessageAboveL = null; &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(null); uploadMessage = null; &#125; &#125; &#125;//选择图片 @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123; if (uploadMessageAboveL == null) &#123; return; &#125; Uri[] results = null; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; String dataString = intent.getDataString(); LogUtils.e(&quot;web&quot;, dataString); ClipData clipData = intent.getClipData(); if (clipData != null) &#123; results = new Uri[clipData.getItemCount()]; for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123; ClipData.Item item = clipData.getItemAt(i); results[i] = item.getUri(); &#125; &#125; if (dataString != null) &#123; results = new Uri[]&#123;Uri.parse(dataString)&#125;; &#125; &#125; &#125; uploadMessageAboveL.onReceiveValue(results); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); uploadMessage = null; uploadMessageAboveL = null; &#125;//将文件File转成Uri public Uri getImageContentUri(Context context, File imageFile) &#123; String filePath = imageFile.getAbsolutePath(); Cursor cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new String[]&#123;MediaStore.Images.Media._ID&#125;, MediaStore.Images.Media.DATA + &quot;=? &quot;, new String[]&#123;filePath&#125;, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int id = cursor.getInt(cursor.getColumnIndex(MediaStore.MediaColumns._ID)); Uri baseUri = Uri.parse(&quot;content://media/external/images/media&quot;); return Uri.withAppendedPath(baseUri, &quot;&quot; + id); &#125; else &#123; if (imageFile.exists()) &#123; ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DATA, filePath); return context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; else &#123; return null; &#125; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Container控件]]></title>
    <url>%2F2018%2F12%2F29%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Container%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flutter练习 - Container控件 属性 key： Container唯一标识符，用于查找更新。 alignment： 控制child的对齐方式，如果container或者container父节点尺寸大于child的尺寸，这个属性设置会起作用，有很多种对齐方式。 padding： decoration内部的空白区域，如果有child的话，child位于padding内部。padding与margin的不同之处在于，padding是包含在content内，而margin则是外部边界，设置点击事件的话，padding区域会响应，而margin区域不会响应。 color： 用来设置container背景色，如果foregroundDecoration设置的话，可能会遮盖color效果。 decoration： 绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。 foregroundDecoration： 绘制在child前面的装饰。 width： container的宽度，设置为double.infinity可以强制在宽度上撑满，不设置，则根据 child和父节点两者一起布局。 height： container的高度，设置为double.infinity可以强制在高度上撑满。 constraints： 添加到child上额外的约束条件。 margin： 围绕在decoration和child之外的空白区域，不属于内容区域。 transform： 设置container的变换矩阵，类型为Matrix4。 child： container中的内容widget。 实例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp(new myApp());&#125;class myApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;text&quot;, home: Scaffold( appBar: AppBar( title: Text(&quot;Container练习&quot;), ), body: Container( constraints: new BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, ), decoration: new BoxDecoration( //边框 border: new Border.all(width: 2.0, color: Colors.red), //背景色 color: Colors.grey, //边框圆角 borderRadius: new BorderRadius.all(new Radius.circular(20.0)), image: new DecorationImage( image: new NetworkImage( &quot;http://www.zhangjiaxue.cn/images/avatar.jpg&quot;), centerSlice: new Rect.fromLTRB(270.0, 180.0, 1360.0, 730.0), ), ), padding: const EdgeInsets.all(8.0), alignment: Alignment.center, child: new Text( &apos;Hello World&apos;, style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.blue), ), //变换矩阵 transform: new Matrix4.rotationZ(0.3), ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - flutter基本控件]]></title>
    <url>%2F2018%2F12%2F26%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-%20flutter%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Flutter 基本控件 Widget StatelessWidget — 只能用来展示信息，不能有用户交互 StatefulWidget — 可以通过改变状态使得 UI 发生变化 文本 Text 123456class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Text(&quot;text&quot;); &#125;&#125; 图片 Image 资源：Image.asset(name); 文件：Image.file(file); 内存：Image.memory(bytes); 网络：Image.network(src); 12345678910class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Image.network( &quot;http://www.zhangjiaxue.cn/images/avatar.jpg&quot;, width: 150.0, height: 150.0, ); &#125;&#125; 按钮（ FlatButton ，RaisedButton ） FlatButton RaisedButton 12345678910111213141516class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var flatBtn = FlatButton( //按钮被点击的时候得到回调 onPressed: () =&gt; print(&apos;FlatButton pressed&apos;), //设置按钮的内容 child: Text(&apos;FlatButton BUTTON&apos;), ); var raisedButton = RaisedButton( onPressed: () =&gt; print(&apos;RaisedButton pressed&apos;), child: Text(&apos;RaisedButton BUTTON&apos;), ); return raisedButton; &#125;&#125; 文本输入框 TextField 123456789class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text(&quot;输入&quot;)), body: TextField(), ); &#125;&#125; 显示弹框 dialog 1234567891011121314151617181920212223242526class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( child: Text(&quot;点击按钮弹出Dialog&quot;), onPressed: () &#123; showDialog( // 第一个 context 是参数名，第二个 context 是 State 的成员变量 context: context, builder: (_) &#123; return AlertDialog( // dialog 的内容 content: Text(&quot;提示框&quot;), // actions 设置 dialog 的按钮 actions: &lt;Widget&gt;[ FlatButton( child: Text(&apos;OK&apos;), // 用户点击按钮后，关闭弹框 onPressed: () =&gt; Navigator.pop(context), ) ], ); &#125;); &#125;); &#125;&#125; 布局 Container（容器） 12345678910111213141516171819202122class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( padding: EdgeInsets.all(8.0), margin: EdgeInsets.all(4.0), width: 200.0, height: 200.0, decoration: BoxDecoration( // 背景色 color: Colors.grey, // 圆角 borderRadius: BorderRadius.circular(5.0), ), // 把文本放在 Container 的中间 child: Center( child: Text(&apos;text&apos;), ), ); &#125;&#125; Row(水平布局) 12345678910111213141516class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //水平布局 return Row( // 只有一个子元素的 widget，一般使用 child 参数来设置；Row 可以包含多个子控件， // 对应的则是 children。 children: &lt;Widget&gt;[ Text(&apos;text1&apos;), Text(&apos;text2&apos;), Text(&apos;text3&apos;), Text(&apos;text4&apos;), ], ); &#125;&#125; Column(竖直布局) 1234567891011121314class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //垂直布局 return Column( children: &lt;Widget&gt;[ Text(&apos;text1&apos;), Text(&apos;text2&apos;), Text(&apos;text3&apos;), Text(&apos;text4&apos;), ], ); &#125;&#125; Stack(层叠布局) 123456789101112131415161718class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Stack( // Aligment 的取值范围为 [-1, 1]，Stack 中心为 (0, 0)， // 这里设置为 (-0.5, -0.5) 后，可以让文本对齐到 Container 的 1/4 处 alignment: const Alignment(-0.5, -0.5), children: &lt;Widget&gt;[ Container( width: 200, height: 200, color: Colors.blue, ), Text(&quot;text2&quot;), ], ); &#125;&#125; 布局控件 Flexible Flexible组件可以使Row、Column、Flex等子组件在主轴方向有填充可用空间的能力(例如，Row在水平方向，Column在垂直方向)，但是它与Expanded组件不同，它不强制子组件填充可用空间。 123456789101112131415161718192021222324252627282930313233343536class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&apos;水平方向布局&apos;), ), body: new Row(children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&apos;点击红色按钮事件&apos;); &#125;, color: Colors.red, child: new Text(&apos;红色按钮&apos;), ), new Flexible( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&apos;点击黄色按钮事件&apos;); &#125;, color: Colors.yellow, child: new Text(&apos;黄色按钮&apos;), ), ), new RaisedButton( onPressed: () &#123; print(&apos;点击蓝色按钮事件&apos;); &#125;, color: Colors.blue, child: new Text(&apos;蓝色按钮&apos;), ), ]), ); &#125;&#125; Expanded Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。 123456789101112131415161718192021222324252627282930313233343536class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&apos;水平方向布局&apos;), ), body: new Row(children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&apos;点击红色按钮事件&apos;); &#125;, color: Colors.red, child: new Text(&apos;红色按钮&apos;), ), new Expanded( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&apos;点击黄色按钮事件&apos;); &#125;, color: Colors.yellow, child: new Text(&apos;黄色按钮&apos;), ), ), new RaisedButton( onPressed: () &#123; print(&apos;点击蓝色按钮事件&apos;); &#125;, color: Colors.blue, child: new Text(&apos;蓝色按钮&apos;), ), ]), ); &#125;&#125; 非常感谢 Flutter学习指南：UI布局和控件（微信号：玉刚说 YugangTalk），作者：水晶虾饺 flutter控件Flexible和 Expanded的区别 ，作者：chunchun1230]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 数组练习]]></title>
    <url>%2F2018%2F12%2F17%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 数组练习 数组创建 使用arrayOf()函数：这种方式无需显示指定数组的长度，但需要依次列出每个数组元素。 1234567fun main(args: Array&lt;String&gt;) &#123; //创建包含指定元素的数组 var arg1 = arrayOf(&quot;Java&quot;,&quot;Kotlin&quot;,&quot;PHP&quot;,&quot;Swift&quot;) var arg2 = arrayOf(0,1,2,3,4,5) println(&quot;arg1 = $&#123;Arrays.toString(arg1)&#125;&quot;) println(&quot;arg2 = $&#123;Arrays.toString(arg2)&#125;&quot;)&#125; 使用arrayOfNulls()函数：这种方法需要显示指定数组的长度，数组元素全部被初始化为null。 1234fun main(args: Array&lt;String&gt;) &#123; //创建指定长度，元素为null的数组 var arg3 = arrayOfNulls&lt;Int&gt;(5)&#125; 使用emptyArray()函数：这种方法会创建一个长度为0的空数组。 12345fun main(args: Array&lt;String&gt;) &#123; //创建长度为0的空数组 var arg4 = emptyArray&lt;String&gt;() var arg5 = emptyArray&lt;Int&gt;()&#125; 使用Array(size : Int,init ：(Int) -&gt; T )构造器：这种方法需要显示指定数组的长度，并可通过Lambda表达式来动态计算各数组元素的值， 1234567fun main(args: Array&lt;String&gt;) &#123; //创建指定长度，使用Lambda表达式初始化数组元素的数组 var arg6 = Array(5,&#123;(it * 2+97).toChar()&#125;) var arg7 = Array(6,&#123;&quot;fkit&quot;&#125;) println(&quot;arg6 = $&#123;Arrays.toString(arg6)&#125;&quot;) println(&quot;arg7 = $&#123;Arrays.toString(arg7)&#125;&quot;)&#125; 其他 Array：Kotlin专门提供了 ByteArray、ShortArray、IntArra、LongArray、CharArray、FloatArray、DoubleArray、BooleanArray 分别对应java中的 byte[]、short[]、int[]、long[]、char[]、floar[]、double[]、boolean[] 这8种基本数据类型的数组。 1234567891011fun main(args: Array&lt;String&gt;) &#123; var intArr = intArrayOf(2,3,4,5,6) var doubleArr = doubleArrayOf(2.1,2.2,2.3,2.4) var intArr2 = IntArray(5,&#123;it*it&#125;) var charArr = CharArray(5,&#123;(it*2+97).toChar()&#125;) println(&quot;intArr = $&#123;Arrays.toString(intArr)&#125;&quot;) println(&quot;doubleArr = $&#123;Arrays.toString(doubleArr)&#125;&quot;) println(&quot;intArr2 = $&#123;Arrays.toString(intArr2)&#125;&quot;) println(&quot;charArr = $&#123;Arrays.toString(charArr)&#125;&quot;)&#125; 数组使用 get(index) 方法 ，set(index，value)方法 12345678fun main(args: Array&lt;String&gt;) &#123; var strArray = arrayListOf&lt;String&gt;(&quot;Java&quot;,&quot;Kotlin&quot;,&quot;Go&quot;,&quot;Swift&quot;) println(strArray[1])//Kotlin println(strArray.get(1))//Kotlin strArray.set(0,&quot;Python&quot;) strArray[2] = &quot;Groovy&quot; println(strArray.toString())//[Python, Kotlin, Groovy, Swift]&#125; 数组遍历 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; var books = arrayListOf&lt;String&gt;(&quot;疯狂java讲义&quot;, &quot;疯狂android讲义&quot;, &quot;疯狂kotlin讲义&quot;) for (book in books) &#123; println(book) &#125; for (i in 0 until books.size) &#123; println(books[i]) &#125; //根据数组的索引来遍历数组 for (i in books.indices)&#123;//索引 = size -1 println(books[i]) &#125; for ((index,value) in books.withIndex())&#123;//索引 = size -1 println(&quot;索引为$&#123;index&#125;的元素为：$&#123;value&#125;&quot;) &#125;&#125; 数组常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153var indexs = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) //所有元素都要满足条件则返回 true var isAll = indexs.all &#123; x -&gt; x &gt; 0 &amp;&amp; x &lt; 10 &#125; print(isAll)//true //任一数组元素满足条件则返回 true var isAny = indexs.any &#123; x -&gt; x == 9 &#125; println(isAny)//true //将数组转为List集合 var indexList = indexs.asList() println(indexList.toString()) //返回Map集合 var indexMap1 = indexs.associate &#123; x -&gt; x to x * x &#125; println(indexMap1.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; var indexMap2 = indexs.associate &#123; it to it * it &#125; println(indexMap2.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //返回Map集合 var indexMap3 = indexs.associateBy &#123; it * it &#125;//Map&lt;K,T&gt;中的K println(indexMap3.toString())//&#123;1=1, 4=2, 9=3, 16=4, 25=5, 36=6, 49=7, 64=8, 81=9&#125; var indexMap4 = indexs.associateBy(&#123; it &#125;, &#123; it * it &#125;) println(indexMap4.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; var indexMap5 = indexs.associateBy(&#123; it * it &#125;)//Map&lt;K,T&gt;中的K println(indexMap5.toString())//&#123;1=1, 4=2, 9=3, 16=4, 25=5, 36=6, 49=7, 64=8, 81=9&#125; //在将数组转成的Map集合插入map，最后返回修改后的map var map6 = mutableMapOf(10 to 100, 11 to 121, 12 to 144) var indexMap6 = indexs.associateByTo(map6, &#123; it &#125;, &#123; it * it &#125;) println(map6.toString())//&#123;10=100, 11=121, 12=144, 1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //在将数组转成的Map集合插入map，最后返回修改后的map var map7 = mutableMapOf(10 to 100, 11 to 121, 12 to 144) var indexMap7 = indexs.associateTo(map7, &#123; it to it * it &#125;) println(map7.toString())//&#123;10=100, 11=121, 12=144, 1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //数组平均值 var average = indexs.average(); println(&quot;平均值为$average&quot;)//5.0 //通过二分法查询element出现的索引，如果找不到则返回负数-------要求数组中的元素已经按升序排序 var binarySearch1 = indexs.binarySearch(4, 0, 3) println(&quot;4在数组(数组从第一个元素,到第三个元素)中的位置：$binarySearch1&quot;)//-4 var binarySearch2 = indexs.binarySearch(4) println(&quot;4在数组中的位置：$binarySearch2&quot;)//3 //判断数组中是否包含元素 var contains = indexs.contains(10); println(&quot;数组中是否有元素10：$&#123;contains&#125;&quot;)//false var indexs1 = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9) //判断两个数组是否相等 var contentDeepEquals = indexs.contentDeepEquals(indexs1) println(&quot;两个数组是否相等：$&#123;contentDeepEquals&#125;&quot;)//true //将数组转成String var str_index = indexs.contentToString(); println(str_index)//[1, 2, 3, 4, 5, 6, 7, 8, 9] //复制数组成为一个新数组 var copyof1 = indexs.copyOf() println(&quot;copyof1 = $&#123;copyof1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9] indexs[0] = 0; println(&quot;copyof1 = $&#123;copyof1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9] indexs[0] = 1; var copyof2 = indexs.copyOf(5) println(&quot;copyof2 = $&#123;copyof2.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5] var copyof3 = indexs.copyOf(10) println(&quot;copyof3 = $&#123;copyof3.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] //复制数组（通过索引指定） var copyOfRange1 = indexs.copyOfRange(0, 10) println(&quot;copyOfRange1 = $&#123;copyOfRange1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] indexs[0] = 10 println(&quot;copyOfRange1 = $&#123;copyOfRange1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] indexs[0] = 1 var copyOfRange2 = indexs.copyOfRange(0, 5) println(&quot;copyOfRange2 = $&#123;copyOfRange2.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5] //数组满足条件的数量 var count1 = indexs.count(&#123; it &gt; 5 &#125;) println(&quot;数组中大于5的元素有：$&#123;count1&#125;个&quot;)//4 var indexs2 = arrayOf(1, 2, 3, 1, 4, 2, 3, 4, 1) //去掉数组中重复的元素 var indexs2_distinct1 = indexs2.distinct() println(indexs2_distinct1.toString())//[1, 2, 3, 4] var indexs2_distinct2 = indexs2.distinctBy &#123; it % 2 == 0 &#125; println(indexs2_distinct2.toString())//[1, 2] //去掉数组中前3个元素 var drop = indexs.drop(3); println(drop.toString()) //去掉前面满足条件的元素，当出现第一个条件不满足时，返回后面的所有元素 var dropWhile = indexs.dropWhile &#123; it &lt;= 3 &#125; println(dropWhile.toString())//[4, 5, 6, 7, 8, 9] //去掉数组中后3个元素 var dropLast = indexs.dropLast(3); println(dropLast.toString())//[1, 2, 3, 4, 5, 6] //去掉前面满足条件的元素，当出现第一个条件不满足时，返回前面的所有元素 var dropLastWhile = indexs.dropLastWhile &#123; it &gt; 6 &#125; println(dropLastWhile.toString())//[1, 2, 3, 4, 5, 6] //将数组中的元素赋值为element var indexs4 = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) indexs4.fill(3) println(indexs4.contentToString())//[3, 3, 3, 3, 3, 3, 3, 3, 3] var indexs5 = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) indexs5.fill(3, 0, 5); println(indexs5.contentToString())//[3, 3, 3, 3, 3, 6, 7, 8, 9] var first1 = indexs.first() println(&quot;数组的第一个元素：$&#123;first1&#125;&quot;)//1 var first2 = indexs.first &#123; it &gt; 5 &#125; println(&quot;数组的第一个满足条件的元素：$&#123;first2&#125;&quot;)//6 var last1 = indexs.last() println(&quot;数组的最后一个元素：$&#123;last1&#125;&quot;)//9 var last2 = indexs.last &#123; it &gt; 5 &#125; println(&quot;数组的最后一个满足条件的元素：$&#123;last2&#125;&quot;)//9 //求和 var fold = indexs.fold(0, &#123; acc, i -&gt; acc + i &#125;) println(&quot;数组元素和为：$&#123;fold&#125;&quot;) //搜索元素查询的位置 var index1 = indexs.indexOf(5)//从前往后 var index2 = indexs.lastIndexOf(5)//从后往前 println(&quot;元素5在数组中的位置是：$&#123;index1&#125;和$&#123;index2&#125;&quot;) var indexs6 = arrayOf(1, 2, 3, 1, 4, 2, 3, 4, 1) var index3 = indexs6.indexOfFirst &#123; it == 3 &#125;//第一次出现的位置 var index4 = indexs6.indexOfLast &#123; it == 3 &#125;//最后一次查询的位置 println(&quot;元素3在数组中第一次出现在$&#123;index3&#125;,最后一次出现在$&#123;index4&#125;&quot;)//2,6 var indexs7 = arrayListOf&lt;Int&gt;(3, 4, 5, 6, 7, 8, 9) var indexs8 = arrayListOf&lt;Int&gt;(1, 2, 5, 6) //intersect(交集)，subtract(差集)，union(并集)，minus(补集) var intersect = indexs7.intersect(indexs8) var subtract = indexs7.subtract(indexs8) var union = indexs7.union(indexs8) var minus = indexs7.minus(indexs8) println(&quot;交集：$&#123;intersect&#125;&quot;)//[5, 6] println(&quot;差集：$&#123;subtract&#125;&quot;)//[3, 4, 7, 8, 9] println(&quot;并集：$&#123;union&#125;&quot;)//[3, 4, 5, 6, 7, 8, 9, 1, 2] println(&quot;补集：$&#123;minus&#125;&quot;)//[3, 4, 7, 8, 9] //数组最大值 var max = indexs.max();//9 //数组最小值 var min = indexs.min();//1 println(&quot;数组中的最大值：$&#123;max&#125; 最小值：$&#123;min&#125;&quot;) var indexs9 = arrayListOf&lt;Int&gt;(1, 9, 3, 7, 2, 5, 4, 6, 8) //排序 indexs9.sort(); println(indexs9)//[1, 2, 3, 4, 5, 6, 7, 8, 9] //排序 val mapList = mutableListOf(1 to &quot;A&quot; , 2 to &quot;B&quot;, 5 to &quot;C&quot;, 3 to &quot;D&quot;) mapList.sortBy &#123; it.first &#125; println(mapList) // [(1, A), (2, B), (3, D), (5, C)] mapList.sortBy &#123; it.second &#125; println(mapList) // [(1, A), (2, B), (5, C), (3, D)]]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 循环练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 循环练习 for-in 循环 for-in 循环语法格式 for（常量名 in 字符串|范围|集合）{} 123456//循环打印1-10fun main (args : Array&lt;String&gt;)&#123;for(num in 1..10)&#123; println(&quot;num = $num&quot;)&#125;&#125; while 循环 while循环语法格式 [init_statements] while (test_expression){ body_statements [iteration_statements] } while每次在执行循环体之前，都要先对test_expression 循环条件求值，如果循环条件为真，则运行循环体。从上面的语法格式来看，迭代语句 iteration_statements 总是位于循环体的最后，因此只有当循环体能成功执行完成时，while循环才会执行迭代语句iteration_statements；如果test_expression 循环条件为假，则循环体部分将不会执行。 1234567891011//循环 0-10fun main (args : Array&lt;String&gt;)&#123; var num =0 println(&quot;循环开始&quot;) while (num&lt;10)&#123; println(&quot;num = $num&quot;) //迭代语句 num++ &#125; println(&quot;循环结束&quot;)&#125; do while 循环 do while循环语法格式 [init_statements] do{ body_statements [iteration_statements] } while (test_expression){ } do while 循环 先执行循环体，再判断循环条件，如果条件为真，则执行下一次循环，否则中止循环 123456789fun main (args : Array&lt;String&gt;)&#123; var num =0 println(&quot;循环开始&quot;) do&#123; println(&quot;num = $num&quot;) num++ &#125;while (num&lt;10) println(&quot;循环结束&quot;)&#125; 嵌套循环 使用 for-in 和 while 嵌套循环 12345678910fun main (args : Array&lt;String&gt;)&#123; println(&quot;循环开始&quot;) for(i in 0 until 10)&#123;//0-9 var j = 0 while (j&lt;3)&#123; println(&quot;i = $i +，j = $&#123;j++&#125;&quot;) &#125; &#125; println(&quot;循环结束&quot;)&#125; 控制循环 使用break结束循环 12345678910fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) for (i in 0..10) &#123;//0-10 println(&quot;i = $i&quot;) if (i==3)&#123; break//结束循环 &#125; &#125; println(&quot;循环结束&quot;)&#125; 使用标识符@ 12345678910111213141516171819fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) outer@ for (i in 0..10) &#123;//0-10 for (j in 0 until 3)&#123;//0-2 println(&quot;i = $i ,j = $j&quot;) if(j==1)&#123; //跳出outer标签所标识的循环 break@outer &#125; &#125; &#125; println(&quot;循环结束&quot;)&#125;运行结果： 循环开始 i = 0 ,j = 0 i = 0 ,j = 1 循环结束 ** 代码解释： ​ 程序从外层循环进入内层循环后，当j等于1时，程序执行break@outer语句，这条语句将会结束outer@标签指定的循环。（并不是结束break所在的内层循环，而是结束 outer@标签所标识的外层循环） ** 注意： ​ 通常警跟break之后的标签，必须在break所在的循环的外层循环之前定义才有意义 使用continue忽略本次循环剩下的语句 使用continue结束本次循环 12345678910fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) for (i in 0..10) &#123;//0-10 if (i == 2) &#123; continue//结束本次循环 &#125; println(&quot;i = $i&quot;) &#125; println(&quot;循环结束&quot;)&#125; 使用标识符@ 12345678910111213141516171819202122fun main(args: Array&lt;String&gt;) &#123; //外层循环 outer@ for (i in 0..3) &#123;//0-3 // 内层循环 for (j in 0 until 3)&#123;//0-2 println(&quot;i = $i ,j = $j&quot;) if(j==1)&#123; //忽略outer标签所标识的循环中当次循环剩下的语句 continue@outer &#125; &#125; &#125; &#125;循环结果： i = 0 ,j = 0 i = 0 ,j = 1 i = 1 ,j = 0 i = 1 ,j = 1 i = 2 ,j = 0 i = 2 ,j = 1 i = 3 ,j = 0 i = 3 ,j = 1 代码解释 程序从外层循环进入内层循环后，当j等于1时，程序执行continue@outer语句，这条语句将会结束outer@标签指定的循环的当次循环，直接开始下一次循环，内层循环没有机会执行完成。 使用return结束方法 使用return语句结束函数或方法 123456789101112131415fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) text() println(&quot;循环结束&quot;)&#125;fun text()&#123;//循环到3后，结束循环for(i in 0 until 10)&#123;//0-9println(&quot;i = $i&quot;) if(i==3)&#123; return &#125; //当i等于3时，无法执行 println(&quot;循环中...&quot;)&#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - when分支结构练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-when%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - when分支练习 when表达式 12345when(expression)&#123;expression1 -&gt; statements...expression2 -&gt; statements...else -&gt; statements...&#125; 例子1 12345678910fun main(args: Array&lt;String&gt;) &#123; var score = &apos;B&apos; when (score) &#123; &apos;A&apos; -&gt; println(&quot;优秀&quot;) &apos;B&apos; -&gt; println(&quot;良好&quot;) &apos;C&apos; -&gt; println(&quot;中&quot;) &apos;D&apos; -&gt; println(&quot;及格&quot;) else -&gt; println(&quot;不及格&quot;) &#125;&#125; 例子2 123456789101112fun main(args: Array&lt;String&gt;) &#123; var score = &apos;c&apos; when (score) &#123; &apos;A&apos;, &apos;a&apos; -&gt; println(&quot;优秀&quot;) &apos;B&apos;, &apos;b&apos; -&gt; println(&quot;良好&quot;) &apos;C&apos;, &apos;c&apos; -&gt; println(&quot;中&quot;) &apos;D&apos;, &apos;d&apos; -&gt; println(&quot;及格&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子3 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = &apos;A&apos; var str = &quot;EFGH&quot; when (score) &#123; str[0]-4,str[1]-4 -&gt; println(&quot;优秀&quot;) str[2]-4,str[3]-4 -&gt; println(&quot;中&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子4 123456789fun main(args: Array&lt;String&gt;) &#123; var date = Date() when (date) &#123; Date() -&gt; println(&quot;优秀&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子5 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = &apos;B&apos; var str = when (score) &#123; &apos;A&apos; -&gt; &quot;优秀&quot; &apos;B&apos; -&gt; &quot;良好&quot; &apos;C&apos; -&gt; &quot;中&quot; &apos;D&apos; -&gt; &quot;及格&quot; else -&gt; &quot;不格&quot; &#125; println(str)&#125; 例子6 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = Random().nextInt(100) var str = when (score) &#123; in 90..100 -&gt; &quot;优秀&quot; in 80..90 -&gt; &quot;良好&quot; in 70..80 -&gt; &quot;中&quot; in 60..70 -&gt; &quot;及格&quot; else -&gt; &quot;不及格&quot; &#125; println(&quot;$&#123;score&#125; = $&#123;str&#125;&quot;)&#125; 例子7 12345678910fun main(args: Array&lt;String&gt;) &#123; var inputPrice = &quot;09&quot; println(realPrice(inputPrice))&#125;fun realPrice(inputPrice:Any)=when(inputPrice)&#123; is String -&gt; inputPrice.toDouble()//如果inputPrice类型为String,返回该字符的Double值 is Int -&gt; inputPrice.toDouble()//如果inputPrice类型为Int,返回该字符的Double值 is Double -&gt; inputPrice else -&gt; 0.0&#125; 例子8 12345678910111213fun main(args: Array&lt;String&gt;) &#123; println(&quot;请输入内容&quot;) val string = readLine()//读取控制台的一行输入 类型: String? if(string!=null)&#123; when&#123; //每个分支条件都需要是布尔表达式 string.matches(Regex(&quot;\\d+&quot;)) -&gt; println(&quot;您输入的全是数字&quot;) string.matches(Regex(&quot;[a-zA-Z]+&quot;)) -&gt; println(&quot;您输入的全是字母&quot;) string.matches(Regex(&quot;[a-zA-Z0-9]+&quot;)) -&gt; println(&quot;您输入的既有数字也有字母&quot;) else -&gt; println(&quot;您输入的内容中包含了特殊字符&quot;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - if分支结构练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-if%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - if分支结构练习 if 分支 常见形式： 第一种形式 123if(expression)&#123; statements...&#125; 第二种形式 12345if(expression)&#123; statements...&#125;else&#123; statements...&#125; 第三种形式 123456if(expression)&#123; statements...&#125;else if(expression)&#123; statements...&#125;... //可以有零个或多个else判断 注意事项 通常建议不要省略if、else、else if后执行体的花括号{}，即使条件执行体只有一行代码，也要保留花括号，这样有更好的可读性，也可以避免发生错误的可能。 表达式 1var str = if (age&gt;20) &quot;age大于20&quot; else if (age&lt;20) &quot;age小于20&quot; else &quot;age等于20&quot; 123456789101112var age = 20var str = if (age &gt; 20) &#123; println(&quot;age大于20的分支&quot;) &quot;age大于20&quot;&#125; else if (age &lt; 20) &#123; println(&quot;age小于20的分支&quot;) &quot;age小于20&quot;&#125; else &#123; println(&quot;age等于20的分支&quot;) &quot;age等于20&quot;&#125;println(str)]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
