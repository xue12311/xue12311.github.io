<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Divider]]></title>
    <url>%2F2021%2F05%2F27%2FJetpack%20Compose%2FJetpack%20Compose%20Divider%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Divider 分割线 Divider 分割线 基本使用 12345678910111213141516171819202122232425262728@Composablefun ComposableSample() &#123; Column(Modifier.fillMaxWidth()) &#123; Text("Hello Word Hello Word Hello Word") //分割线 Divider( //颜色 color = Color.Blue, //线的高度 thickness = 1.dp, //距离开始的间距 startIndent = 10.dp ) Text("Hello Word") //分割线 Divider( Modifier .fillMaxWidth() .height(1.dp) .padding(start = 10.dp, end = 10.dp), //颜色 color = Color.Green, ) Text("Hello Word Hello Word") Text("Hello Word Hello Word Hello Word") &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 AnimationVisibility]]></title>
    <url>%2F2021%2F05%2F27%2FJetpack%20Compose%2FJetpack%20Compose%20AnimationVisibility%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- AnimationVisibility AnimationVisibility 动画 可见 基础用法 12345678910111213141516171819202122232425262728293031@ExperimentalAnimationApi@Composablefun ComposableSample() &#123; var state by remember &#123; mutableStateOf(true) &#125; Column( Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) &#123; AnimatedVisibility(visible = state) &#123; Text( text = "这是一个普通的正文", fontWeight = FontWeight.W900, style = MaterialTheme.typography.h5 ) &#125; Spacer(modifier = Modifier.height(50.dp)) Button(onClick = &#123; state = !state &#125;) &#123; Text( text = if (state) &#123; "隐藏" &#125; else &#123; "显示" &#125; ) &#125; &#125;&#125; 进场动画 123456789101112131415161718192021222324252627282930313233343536373839@ExperimentalAnimationApi@Composablefun ComposableSample() &#123; var state by remember &#123; mutableStateOf(true) &#125; Column( Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) &#123; AnimatedVisibility( visible = state, enter = slideInVertically( //初始位置 Y轴 initialOffsetY = &#123; -1000 &#125;, animationSpec = tween( //动画持续时间 durationMillis = 1200 ) ) ) &#123; Text( text = "这是一个普通的正文", fontWeight = FontWeight.W900, style = MaterialTheme.typography.h5 ) &#125; Spacer(modifier = Modifier.height(50.dp)) Button(onClick = &#123; state = !state &#125;) &#123; Text( text = if (state) &#123; "隐藏" &#125; else &#123; "显示" &#125; ) &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@ExperimentalAnimationApi@Composablefun ComposableSample() &#123; var state by remember &#123; mutableStateOf(true) &#125; Column( Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) &#123; AnimatedVisibility( visible = state, //垂直滑入 enter = slideInVertically( //初始位置 Y轴 initialOffsetY = &#123; -1000 &#125;, animationSpec = tween( //动画持续时间 durationMillis = 1200 ) //淡入 ) + fadeIn( animationSpec = tween( //动画持续时间 durationMillis = 1200 ) ) ) &#123; Text( text = "这是一个普通的正文", fontWeight = FontWeight.W900, style = MaterialTheme.typography.h5 ) &#125; Spacer(modifier = Modifier.height(50.dp)) Button(onClick = &#123; state = !state &#125;) &#123; Text( text = if (state) &#123; "隐藏" &#125; else &#123; "显示" &#125; ) &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Swipeable]]></title>
    <url>%2F2021%2F05%2F27%2FJetpack%20Compose%2FJetpack%20Compose%20Swipeable%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Swipeable 滑动 Swipeable 滑动 基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Composablefun ComposableSample() &#123; var blockSize = 48.dp var blockSizePx = with(LocalDensity.current) &#123; blockSize.toPx() &#125; var swipeableState = rememberSwipeableState(initialValue = Status.CLOSE) var anchors = mapOf( 0f to Status.CLOSE, blockSizePx to Status.OPEN ) Box( modifier = Modifier .size( height = blockSize, width = blockSize * 2 ) .background(Color.LightGray) ) &#123; Box( modifier = Modifier //滑动 .swipeable( state = swipeableState, //锚点，可以通过锚点设置在不同状态时所应该对应的偏移量信息 anchors = anchors, //常用作定制不同锚点间吸附效果的临界阈值 //常用有 FixedThreshold(Dp) 和 FractionalThreshold(Float)等 thresholds = &#123; from, to -&gt; if (from == Status.CLOSE) &#123; FractionalThreshold(0.3f) &#125; else &#123; FractionalThreshold(0.5f) &#125; &#125;, //手势方向，被修饰组件的手势方向只能是水平或垂直 orientation = Orientation.Horizontal, ) //移动 .offset &#123; //整体移动 IntOffset(swipeableState.offset.value.toInt(), 0) &#125; .size(blockSize) .background(Color.DarkGray) ) &#125;&#125;enum class Status &#123; CLOSE, OPEN&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 ModalBottomSheetLayout]]></title>
    <url>%2F2021%2F05%2F27%2FJetpack%20Compose%2FJetpack%20Compose%20ModalBottomSheetLayout%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- ModalBottomSheetLayout 底部弹出布局 ModalBottomSheetLayout 底部弹出布局 基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@ExperimentalMaterialApi@Composablefun ComposableSample() &#123; val state = rememberModalBottomSheetState(initialValue = ModalBottomSheetValue.Hidden) val scope = rememberCoroutineScope() ModalBottomSheetLayout( sheetContent = &#123; Column &#123; ListItem( text = &#123; Text(text = "选择分享到哪里吧~") &#125; ) ListItem( text = &#123; Text(text = "github") &#125;, icon = &#123; Surface( shape = CircleShape, color = Color(0xFF181717) ) &#123; Icon( painterResource(id = R.drawable.ic_github), null, Modifier.padding(4.dp), Color.White ) &#125; &#125;, modifier = Modifier.clickable &#123; &#125; ) ListItem( text = &#123; Text(text = "wechat") &#125;, icon = &#123; Surface( shape = CircleShape, color = Color(0xFF181717) ) &#123; Icon( painterResource(id = R.drawable.ic_wechat), null, Modifier.padding(4.dp), Color.White ) &#125; &#125;, modifier = Modifier.clickable &#123; &#125; ) ListItem( text = &#123; Text(text = "twitter") &#125;, icon = &#123; Surface( shape = CircleShape, color = Color(0xFF181717) ) &#123; Icon( painterResource(id = R.drawable.ic_twitter), null, Modifier.padding(4.dp), Color.White ) &#125; &#125;, modifier = Modifier.clickable &#123; &#125; ) &#125; &#125;, sheetState = state ) &#123; Column( Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) &#123; Button(onClick = &#123; scope.launch &#123; state.show() &#125; &#125;) &#123; Text(text = "分享") &#125; &#125; &#125; //返回键 处理 ModalBottomSheet 收回 BackHandler( enabled = (state.currentValue == ModalBottomSheetValue.HalfExpanded || state.currentValue == ModalBottomSheetValue.Expanded), onBack = &#123; scope.launch &#123; state.hide() &#125; &#125;)&#125; 收回 ModalBottomSheet 一般情况下，ModalBottomSheet 无法自动处理按下返回键就收起，所以我们可以用 BackHandler 来处理 在 ModalBottomSheet 后添加代码: 12345678910BackHandler( enabled = (state.currentValue == ModalBottomSheetValue.HalfExpanded || state.currentValue == ModalBottomSheetValue.Expanded), onBack = &#123; scope.launch&#123; state.hide() &#125; &#125;) 设置动画时间 ModalSheetLayout 默认用 state.show() 或者 state.hidden() 来弹出和收回 我们可以通过这样的方式来自定义动画时间: 12state.animateTo(ModalBottomSheetValue.Hidden, tween(1000))]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 BottomNavigation]]></title>
    <url>%2F2021%2F05%2F27%2FJetpack%20Compose%2FJetpack%20Compose%20BottomNavigation%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- BottomNavigation 底部导航栏 BottomNavigation 底部导航栏 基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Composablefun ComposableSample() &#123; var selectedItem by remember &#123; mutableStateOf(0) &#125; val list_name = listOf("主页", "喜爱", "设置") val list_icon = listOf(Icons.Filled.Home, Icons.Filled.Favorite, Icons.Filled.Settings) Scaffold( topBar = &#123; //顶部导航栏 TopAppBar( title = &#123; Text(text = list_name.get(selectedItem)) &#125;, navigationIcon = &#123; IconButton(onClick = &#123;&#125;) &#123; Icon(Icons.Filled.ArrowBack, null) &#125; &#125; ) &#125;, bottomBar = &#123; BottomNavigation &#123; list_name.forEachIndexed &#123; index, item -&gt; BottomNavigationItem( selected = selectedItem == index, onClick = &#123; selectedItem = index &#125;, icon = &#123; Icon( imageVector = list_icon[index], contentDescription = null, ) &#125;, label = &#123; Text(text = item) &#125;) &#125; &#125; &#125; ) &#123; Text( text = list_name[selectedItem], Modifier .fillMaxSize() .wrapContentSize(Alignment.Center) ) &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Surface]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20Surface%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Surface 用 Surface 实现 Card 的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Composablefun ComposableSample() &#123; Surface( //设置形状 shape = RoundedCornerShape(10.dp), // 设置阴影 elevation = 10.dp, modifier = Modifier .fillMaxWidth() // 外边距 .padding(15.dp) .clickable &#123; &#125; ) &#123; Column( // 内边距 Modifier.padding(15.dp) ) &#123; Text( buildAnnotatedString &#123; append("welcome to ") withStyle( style = SpanStyle( color = Color(0xFF4552B8), fontWeight = FontWeight.W900, ) ) &#123; append("Jetpack Compose Playground") &#125; &#125;) Text( buildAnnotatedString &#123; append("Now you are in the ") withStyle( style = SpanStyle( fontWeight = FontWeight.W900, ) ) &#123; append("Card") &#125; append(" section") &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Scaffold]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20Scaffold%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Scaffold Scaffold 基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Composablefun ScaffoldDemo() &#123; val materialBlue700 = Color(0xFF1976D2) //设置抽屉的打开状态 val scaffoldState = rememberScaffoldState( rememberDrawerState(initialValue = DrawerValue.Closed) ) val scope = rememberCoroutineScope() Scaffold( scaffoldState = scaffoldState, //顶部导航栏 topBar = &#123; TopAppBar( title = &#123; Text(text = "标题") &#125;, backgroundColor = materialBlue700, ) &#125;, //悬浮按钮 floatingActionButton = &#123; FloatingActionButton(onClick = &#123; scope.launch &#123; if (scaffoldState.drawerState.isClosed) &#123; scaffoldState.drawerState.open() &#125; else &#123; scaffoldState.drawerState.close() &#125; &#125; &#125;) &#123; Text("X") &#125; &#125;, //悬浮按钮的位置 floatingActionButtonPosition = FabPosition.End, //抽屉内容 drawerContent = &#123; Text(text = "drawerContent") &#125;, //内容 content = &#123; Text("BodyContent") &#125;, //底部导航栏 bottomBar = &#123; BottomAppBar( backgroundColor = materialBlue700 ) &#123; Text(text = "BottomAppBar") &#125; &#125; )&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Slider]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20Slider%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Slider 拖动条 Slider 拖动条 基本使用 1234567891011121314 @Composablefun SliderDemo() &#123; Column(Modifier.padding(10.dp)) &#123; val sliderPosition = remember &#123; mutableStateOf(0f) &#125; Slider(value = sliderPosition.value, onValueChange = &#123; sliderPosition.value = it &#125;) Spacer(modifier = Modifier.height(5.dp)) Text("当前进度: $&#123;sliderPosition.value.toString()&#125;") &#125;&#125; 12345678910111213141516171819@Composable fun ComposableSample() &#123; val sliderPosition = remember &#123; mutableStateOf(0f) &#125; Slider( value = sliderPosition.value, colors = SliderDefaults.colors( //圆圈的颜色 thumbColor = Color.White, //滑条颜色 (注 : 滑条默认颜色:inactiveTrackColor 默认是 与 activeTrackColor 一样 设置了 0.24f 透明度) activeTrackColor = Color(0xFF0079D3) ), onValueChange = &#123; sliderPosition.value = it &#125; ) &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Snackbar]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20Snackbar%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Snackbar Snackbar 基本使用 123456789101112131415161718192021222324252627282930@Composablefun SnackbarDemo() &#123; Column &#123; val snackbarVisibilityState = remember &#123; mutableStateOf(false) &#125; Button( onClick = &#123; snackbarVisibilityState.value = !snackbarVisibilityState.value &#125; ) &#123; if (snackbarVisibilityState.value) &#123; Text("隐藏 Snackbar") &#125; else &#123; Text("显示 Snackbar") &#125; &#125; if (snackbarVisibilityState.value) &#123; Snackbar( action = &#123; Button(onClick = &#123;&#125;) &#123; Text(text = "MyAction") &#125; &#125;, modifier = Modifier.padding(10.dp) ) &#123; Text("This is a snackbar!") &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 TopAppBar]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20TopAppBar%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- TopAppBar 标题 TopAppBar 标题 基本使用 123456789101112131415161718192021222324252627@Composablefun TopAppBarSample() &#123; Column &#123; TopAppBar( elevation = 4.dp, title = &#123; Text("标题内容") &#125;, backgroundColor = MaterialTheme.colors.primarySurface, navigationIcon = &#123; IconButton(onClick = &#123; &#125;) &#123; Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "返回") &#125; &#125;, actions = &#123; IconButton(onClick = &#123;&#125;) &#123; Icon(imageVector = Icons.Filled.Share, contentDescription = "分享") &#125; IconButton(onClick = &#123;&#125;) &#123; Icon(imageVector = Icons.Filled.Settings, contentDescription = "设置") &#125; &#125; ) Text(text = "Hello World") &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Switch]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20Switch%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Switch 开关 Switch 开关 基本使用 123456789101112@Composablefun SwitchSample() &#123; val checkedState = remember &#123; mutableStateOf(true) &#125; Switch(checked = checkedState.value, onCheckedChange = &#123; checkedState.value = it &#125; )&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 RadioButton]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20RadioButton%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- RadioButton 单选按钮 RadioButton 单选按钮 基本使用 123456789101112131415161718192021222324252627282930313233343536@Composablefun RadioButtonSample() &#123; val radioOptions = listOf&lt;String&gt;("A", "B", "C") val (selectedOption, onOptionSelected) = remember &#123; mutableStateOf(radioOptions[1]) &#125; Column &#123; radioOptions.forEach &#123; text -&gt; Row( Modifier .fillMaxWidth() .selectable( selected = text == selectedOption, onClick = &#123; onOptionSelected(text) &#125; ) .padding(horizontal = 16.dp) ) &#123; RadioButton( selected = (selectedOption == text), onClick = &#123; onOptionSelected(text) &#125; ) Text( text = text, style = MaterialTheme.typography.body1.merge(), modifier = Modifier.padding(16.dp) ) &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 ModalDrawerLayout]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20ModalDrawerLayout%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- ModalDrawerLayout 导航抽屉 ModalDrawerLayout 导航抽屉 基本使用 123456789101112131415161718192021222324252627282930313233@Composablefun ModalDrawerLayoutSample() &#123; val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed) val scope = rememberCoroutineScope() ModalDrawer( drawerState = drawerState, drawerContent = &#123; Column &#123; Text(text = "Text in Drawer") Button(onClick = &#123; scope.launch &#123; drawerState.close() &#125; &#125;) &#123; Text(text = "Close Drawer") &#125; &#125; &#125;, content = &#123; Column &#123; Text(text = "Text in Bodycontext") Button(onClick = &#123; scope.launch &#123; drawerState.open() &#125; &#125;) &#123; Text(text = "Open Drawer") &#125; &#125; &#125; )&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 FloatingActionButton]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20FloatingActionButton%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- FloatingActionButton 悬浮按钮 FloatingActionButton 悬浮按钮 基本使用 123456789101112131415161718192021222324@Composablefun FloatingActionButtonSample() &#123; Column(Modifier.padding(10.dp)) &#123; FloatingActionButton( onClick = &#123; &#125;, ) &#123; Text(text = "悬浮按钮") &#125; Spacer(modifier = Modifier.height(30.dp)) ExtendedFloatingActionButton( text = &#123; Text(text = "悬浮按钮") &#125;, icon = &#123; Icon(imageVector = Icons.Filled.Favorite, contentDescription = "喜爱") &#125;, onClick = &#123; &#125;, elevation = FloatingActionButtonDefaults.elevation(8.dp), ) &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 LinearProgressIndicator]]></title>
    <url>%2F2021%2F05%2F26%2FJetpack%20Compose%2FJetpack%20Compose%20LinearProgressIndicator%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- LinearProgressIndicator 线形进度条 LinearProgressIndicator 线形进度条 基本使用 12345678910111213141516171819202122232425262728293031323334353637@Composablefun LinearProgressIndicatorSample() &#123; var progress = remember &#123; mutableStateOf(0.0f) &#125; val animatedProgress = animateFloatAsState( targetValue = progress.value, animationSpec = ProgressIndicatorDefaults.ProgressAnimationSpec ).value Column(horizontalAlignment = Alignment.CenterHorizontally,modifier = Modifier.padding(10.dp)) &#123; Spacer(modifier = Modifier.height(30.dp)) Text(text = "进度 不确定 的 线形进度条") Spacer(modifier = Modifier.height(30.dp)) LinearProgressIndicator() Spacer(modifier = Modifier.height(30.dp)) Text(text = "线形进度条 进度通过 点击按钮 添加") Spacer(modifier = Modifier.height(30.dp)) LinearProgressIndicator(progress = animatedProgress) Spacer(modifier = Modifier.height(30.dp)) OutlinedButton(onClick = &#123; if (progress.value &lt; 1f) &#123; progress.value += 0.1f &#125; &#125;) &#123; Text(text = "添加进度") &#125; Spacer(modifier = Modifier.height(30.dp)) OutlinedButton(onClick = &#123; if (progress.value &gt; 0f) &#123; progress.value -= 0.1f &#125; &#125;) &#123; Text(text = "降低进度") &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 TextField]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20TextField%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- TextField 输入框 TextField 输入框 基本使用 1234567891011121314151617@Composablefun BaseTextFieldDemo() &#123; val textState = rememberSaveable &#123; mutableStateOf("") &#125; Column &#123; TextField( //文本框里的文本内容 value = textState.value, //文本框输入内容时候的回调 onValueChange = &#123; textState.value = it &#125;) Text(text = "您输入的内容: $&#123;textState.value&#125;") &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243@Composablefun ComposableSample() &#123; var phone = rememberSaveable &#123; mutableStateOf("") &#125; Column &#123; TextField( //文本框里的文本内容 value = phone.value, //文本框输入内容时候的回调 onValueChange = &#123; phone.value = it &#125;, modifier = Modifier.fillMaxWidth(), //启用 enabled = true, //只读 readOnly = false, label = &#123; Text(text = "手机号码") &#125;, //在没有输入内容的时候显示，类似于 hint placeholder = &#123; Text(text = "请输入手机号码") &#125;, //显示在文本框左边的控件 leadingIcon = &#123; Icon(Icons.Default.Phone, null) &#125;, //显示在文本框末尾的控件 trailingIcon = &#123; Icon(Icons.Default.Cancel, null) &#125;, //当前文本字段 是否 为 错误的 isError = false, //形状 圆角 shape = RoundedCornerShape(5.dp) ) Spacer(modifier = Modifier.size(20.dp)) Text(text = "您输入的内容: $&#123;phone.value&#125;") &#125;&#125; 12345678910111213@Composablefun TextFieldDemo() &#123; var text by remember &#123; mutableStateOf("") &#125; TextField( value = text, onValueChange = &#123; text = it &#125;, //单行 singleLine = true )&#125; 1234567891011121314@Composablefun ComposableSample() &#123; var text by remember &#123; mutableStateOf("") &#125; TextField( value = text, onValueChange = &#123; text = it &#125;, leadingIcon = &#123; Icon(Icons.Filled.Search, null) &#125;, )&#125; 1234567891011121314@Composablefun ComposableSample() &#123; var text by remember &#123; mutableStateOf("") &#125; TextField( value = text, onValueChange = &#123; text = it &#125;, leadingIcon = &#123; Text("联系人") &#125;, )&#125; TextField 输入和修改文字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 //TextField 输入和修改文字@Composablefun SimpleFilledTextFieldSample() &#123; var text = remember &#123; mutableStateOf("Hello") &#125; TextField( value = text.value, onValueChange = &#123; text.value = it &#125;, label = &#123; Text(text = "Label") &#125; )&#125;//轮廓样式 输入框@Composablefun SimpleOutlinedTextFieldSample() &#123; var text = remember &#123; mutableStateOf("") &#125; OutlinedTextField( value = text.value, onValueChange = &#123; text.value = it &#125;, label = &#123; Text(text = "Label") &#125; )&#125;//设置 TextField 样式@Composablefun StyledTextField() &#123; var text = remember &#123; mutableStateOf("Hello\nWorld\nInvisible") &#125; TextField( value = text.value, onValueChange = &#123; text.value = it &#125;, label = &#123; Text(text = "Enter text") &#125;, maxLines = 2, textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold), modifier = Modifier.padding(20.dp) )&#125;//设置 TextField 格式@Composablefun PasswordTextField() &#123; var password = rememberSaveable &#123; mutableStateOf("") &#125; TextField( value = password.value, onValueChange = &#123; password.value = it &#125;, label = &#123; Text(text = "Enter password") &#125;, //密码样式 visualTransformation = PasswordVisualTransformation(), //设置键盘选项 密码 keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password) )&#125; 123456789101112131415161718@Composablefun ComposableSample() &#123; var text by remember &#123; mutableStateOf("") &#125; TextField( value = text, onValueChange = &#123; text = it &#125;, leadingIcon = &#123; Icon(Icons.Filled.Search, null) &#125;, colors = TextFieldDefaults.textFieldColors( textColor = Color(0xFF0079D3), backgroundColor = Color.Transparent ) )&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Composablefun textFieldColors( // 输入的文字颜色 textColor: Color = LocalContentColor.current.copy(LocalContentAlpha.current), // 禁用 TextField 时，已有的文字颜色 disabledTextColor: Color = textColor.copy(ContentAlpha.disabled), // 输入框的背景颜色，当设置为 Color.Transparent 时，将透明 backgroundColor: Color = MaterialTheme.colors.onSurface.copy(alpha = BackgroundOpacity), // 输入框的光标颜色 cursorColor: Color = MaterialTheme.colors.primary, // 当 TextField 的 isError 参数为 true 时，光标的颜色 errorCursorColor: Color = MaterialTheme.colors.error, // 当输入框处于焦点时，底部指示器的颜色 focusedIndicatorColor: Color = MaterialTheme.colors.primary.copy(alpha = ContentAlpha.high), // 当输入框不处于焦点时，底部指示器的颜色 unfocusedIndicatorColor: Color = MaterialTheme.colors.onSurface.copy(alpha = UnfocusedIndicatorLineOpacity), // 禁用 TextField 时，底部指示器的颜色 disabledIndicatorColor: Color = unfocusedIndicatorColor.copy(alpha = ContentAlpha.disabled), // 当 TextField 的 isError 参数为 true 时，底部指示器的颜色 errorIndicatorColor: Color = MaterialTheme.colors.error, // TextField 输入框前头的颜色 leadingIconColor: Color = MaterialTheme.colors.onSurface.copy(alpha = IconOpacity), // 禁用 TextField 时 TextField 输入框前头的颜色 disabledLeadingIconColor: Color = leadingIconColor.copy(alpha = ContentAlpha.disabled), // 当 TextField 的 isError 参数为 true 时 TextField 输入框前头的颜色 errorLeadingIconColor: Color = leadingIconColor, // TextField 输入框尾部的颜色 trailingIconColor: Color = MaterialTheme.colors.onSurface.copy(alpha = IconOpacity), // 禁用 TextField 时 TextField 输入框尾部的颜色 disabledTrailingIconColor: Color = trailingIconColor.copy(alpha = ContentAlpha.disabled), // 当 TextField 的 isError 参数为 true 时 TextField 输入框尾部的颜色 errorTrailingIconColor: Color = MaterialTheme.colors.error, // 当输入框处于焦点时，Label 的颜色 focusedLabelColor: Color = MaterialTheme.colors.primary.copy(alpha = ContentAlpha.high), // 当输入框不处于焦点时，Label 的颜色 unfocusedLabelColor: Color = MaterialTheme.colors.onSurface.copy(ContentAlpha.medium), // 禁用 TextField 时，Label 的颜色 disabledLabelColor: Color = unfocusedLabelColor.copy(ContentAlpha.disabled), // 当 TextField 的 isError 参数为 true 时，Label 的颜色 errorLabelColor: Color = MaterialTheme.colors.error, // Placeholder 的颜色 placeholderColor: Color = MaterialTheme.colors.onSurface.copy(ContentAlpha.medium), // 禁用 TextField 时，placeholder 的颜色 disabledPlaceholderColor: Color = placeholderColor.copy(ContentAlpha.disabled))]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Text]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Text%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Text 文本 Text 文字 基本属性 text: 显示的文本 modifier color: 字体颜色 fontSize: 字体大小 fontStyle: 字体样式 （比如斜体） fontWeight: 字体样式 (比如粗体) fontFamily: 处理字体 (比如设置宋体等) letterSpacing: 每个字符之间的间距 textDecoration: 文本的装饰，比如TextDecoration.Underline 添加下划线，比如TextDecoration.LineThrough 中线划线 textAlign: 设置文字对齐 对齐方式 lineHeight: 设置行高 maxLines: 最大行数 overflow: 当文字溢出的时候，比如…设置显示在最后 softWrap: 声明是否应在换行符处断开文本,默认是true onTextLayout: 在计算新的文本布局时执行的回调 style: 文本样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167 @Composablefun TextDemo() &#123; //垂直布局 Column() &#123; //显示资源中的文字 Text(stringResource(id = R.string.app_name)) //最多显示行数 , 溢出处理 Text( text = "你好呀陌生人，这是一个标题，不是很长，因为我想不出其他什么比较好的标题了", //宽度 modifier = Modifier.width(200.dp), //设置 最多显示行数 maxLines = 1, //溢出处理 省略 overflow = TextOverflow.Ellipsis ) //文字颜色 Text(text = "Hello World", color = Color.Blue) //文字大小 Text(text = "Hello World", fontSize = 30.sp) //斜体 Text(text = "Hello World", fontStyle = FontStyle.Italic) //粗体 Text(text = "Hello World", fontWeight = FontWeight.Bold) //文字对齐 (居中) Text( text = "Hello World Hello World\nHello World", //文本的对齐方式 textAlign = TextAlign.Center ) //设置宽度与高度 Text( text = "Hello World", //居中对齐 textAlign = TextAlign.Center, modifier = Modifier //宽度 .width(100.dp) //高度 .height(30.dp) ) //字体设置 Text(text = "Hello World", fontFamily = FontFamily.Serif) //字体设置 Text(text = "Hello World", fontFamily = FontFamily.SansSerif) //自定义 fontFamily val firaSansFamily = FontFamily( Font(R.font.firasans_light, FontWeight.Light), Font(R.font.firasans_regular, FontWeight.Normal) ) //字体设置 Text( text = "Hello World", fontFamily = firaSansFamily, fontWeight = FontWeight.Light ) //字体设置 Text( text = "Hello World", fontFamily = firaSansFamily, fontWeight = FontWeight.Normal ) //文本中间绘制线 Text( text = "Hello World", style = TextStyle(textDecoration = TextDecoration.LineThrough) ) //文本下方绘制线 下划线 Text( text = "Hello World", style = TextStyle(textDecoration = TextDecoration.Underline) ) //设置多个 textDecoration Text( text = "Hello World", style = TextStyle( textDecoration = TextDecoration.combine( listOf( TextDecoration.LineThrough, TextDecoration.Underline ) ) ) ) //设置样式 Text(text = buildAnnotatedString &#123; withStyle( style = SpanStyle( //字体颜色 color = Color.Blue ) ) &#123; append("H") &#125; append("ello ") withStyle( style = SpanStyle( //粗体 fontWeight = FontWeight.Bold, //字体颜色 color = Color.Green ) ) &#123; append("W") &#125; append("orld") &#125;) //设置段落样式 Text(text = buildAnnotatedString &#123; withStyle( style = ParagraphStyle( //行高间距 lineHeight = 40.sp ) ) &#123; withStyle( style = SpanStyle( //字体颜色 color = Color.Yellow ) ) &#123; append("Hello\n") &#125; withStyle( style = SpanStyle( //粗体 fontWeight = FontWeight.Bold, //字体颜色 color = Color.Red ) ) &#123; append("World\n") &#125; append("Compose") &#125; &#125;) //设置最大行数 Text( //重复字符串 text = "Hello World ".repeat(20), //设置行数 maxLines = 3 ) //文字溢出处理 Text( text = "Hello World".repeat(20), //设置最大行数 maxLines = 3, //溢出处理：省略号 overflow = TextOverflow.Ellipsis ) // 将内部 Text 组件的 alpha 强调程度设置为高 // 注意: MaterialTheme 已经默认将强调程度设置为 high CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.high) &#123; Text("这里是high强调效果") &#125; // 将内部 Text 组件的 alpha 强调程度设置为中 CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) &#123; Text("这里是medium强调效果") &#125; // 将内部 Text 组件的 alpha 强调程度设置为禁用 CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) &#123; Text("这里是禁用后的效果") &#125; &#125;&#125; SelectionContainer 选择文字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//选择文字//默认情况下，可组合项不可选择，这意味着在默认情况下用户无法从您的应用中选择和复制文字。//要启用文字选择，需要使用 SelectionContainer 可组合项封装文字元素@Composablefun SelectableText() &#123; Text(text = "Hello World")&#125;//DisableSelection 为可选择区域的特定部分停用选择功能@Composablefun PartiallySelectableText() &#123; SelectionContainer &#123; Column &#123; Text("This text is selectable") Text("This one too") Text("This one as well") //组合项来封装不可选择的部分 DisableSelection &#123; Text("But not this one") Text("Neither this one") &#125; Text("But again, you can select this one") Text("And this one too") &#125; &#125;&#125;@Composablefun ComposableSample() &#123; Text( text = "Hello World Hello World Hello World", modifier = Modifier.clickable( onClick = &#123; Log.d("onClick", "你点击了此文本") &#125;, //取消点击波纹 indication = null, //取消点击波纹 interactionSource = MutableInteractionSource() ) )&#125;//clickable 获取点击文字的位置@Composablefun SimpleClickableText() &#123; ClickableText( text = AnnotatedString("Click Me"), onClick = &#123; offset -&gt; Log.d("ClickableText", "$&#123;offset&#125; -th character is clicked.") &#125; )&#125;//点击注解@Composablefun AnnotatedClickableText() &#123; val annotatedText = buildAnnotatedString &#123; append("Click ") //我们将此URL注释附加到以下内容，直到调用`pop（）`为止 pushStringAnnotation( tag = "URL", annotation = "https://developer.android.com" ) withStyle( style = SpanStyle( //字体颜色 color = Color.Red, //粗体 fontWeight = FontWeight.Bold ) ) &#123; append("here") &#125; pop() &#125; ClickableText( text = annotatedText, onClick = &#123; offset -&gt; //判断点击的位置是否是 url 注解中 annotatedText.getStringAnnotations( tag = "URL", start = offset, end = offset ).firstOrNull()?.let &#123; annotation -&gt; Log.d("Clicked URL", annotation.item) &#125; &#125; )&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Shape]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Shape%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Shape 形状 1234567891011121314151617181920212223242526272829303132333435@Composable fun ShapeDemo() &#123; Column( Modifier .fillMaxWidth() ) &#123; //RectangleShape 矩形形状 ExampleBox(shape = RectangleShape) //CircleShape 圆圈形状 ExampleBox(shape = CircleShape) //RoundedCornerShape 圆角形状 ExampleBox(shape = RoundedCornerShape(10.dp)) //CutCornerShape 切角形状 ExampleBox(shape = CutCornerShape(10.dp)) &#125; &#125; @Composable fun ExampleBox(shape: Shape) &#123; Column( Modifier .fillMaxWidth() .padding(10.dp) .wrapContentSize(Alignment.Center) ) &#123; Box( modifier = Modifier .size(100.dp) .clip(shape) .background(Color.Blue) ) &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Modifier]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Modifier%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Modifier padding 设置各个UI的padding 1234567891011121314// 给上下左右全部设置成同一个值Modifier.padding(10.dp)// 分别为左（开始）、上（上）、右（结束）、下（下）设值Modifier.padding(10.dp, 20.dp, 30.dp, 40.dp)// 分别为左右（水平）和上下（垂直）设值Modifier.padding(10.dp, 20.dp)//PaddingValues 与 padding 不一样// 给上下左右全部设置成同一个值Modifier.padding(PaddingValues(10.dp))// 分别为左右（水平）和上下（垂直）设值Modifier.padding(PaddingValues(10.dp, 20.dp))//分别为左（开始）、上（上）、右（结束）、下（下）设值Modifier.padding(PaddingValues(10.dp, 20.dp, 30.dp, 40.dp)) fillMaxHeight,fillMaxWidth,fillMaxSize 类似于match_parent,填充整个父layout 1234567//填充整个父LayoutModifier.fillMaxSize()//填充整个父Layout的宽度Modifier.fillMaxWidth()//填充整个父Layout的高度Modifier.fillMaxHeight() width,heigh,size 设置Content的宽度和高度 123456789//设置宽度Modifier.width(80.dp)//设置高度Modifier.height(80.dp)//设置 宽度和高度Modifier.size(100.dp)//设置 宽度,高度Modifier.size(100.dp, 100.dp) widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值 1234567//设置 最小宽度 最大宽度Modifier.widthIn(20.dp, 50.dp)//设置 最小高度 最大高度Modifier.heightIn(20.dp, 50.dp)//设置 最小宽度,最小高度,最大宽度,最大高度Modifier.sizeIn(20.dp, 20.dp, 50.dp, 50.dp) wrapContentHeight,wrapContentWidth,wrapContentSize, 123456789101112131415161718192021222324252627282930313233// 高度 位于 顶部Modifier.wrapContentHeight(Alignment.Top)// 高度 位于 底部Modifier.wrapContentHeight(Alignment.Bottom)// 高度 位于 垂直居中Modifier.wrapContentHeight(Alignment.CenterVertically)// 高度 位于 水平居中Modifier.wrapContentHeight(Alignment.CenterHorizontally)// 宽度 位于 开始（左）Modifier.wrapContentWidth(Alignment.Start)// 宽度 位于 结束（右）Modifier.wrapContentWidth(Alignment.End)// 宽度 位于 水平居中Modifier.wrapContentWidth(Alignment.CenterHorizontally)// 宽度 位于 垂直居中Modifier.wrapContentWidth(Alignment.CenterVertically)//位置 位于 顶部 开始（左）Modifier.wrapContentSize(Alignment.TopStart)//位置 位于 顶部 结束（右）Modifier.wrapContentSize(Alignment.TopEnd)//位置 位于 顶部 水平居中Modifier.wrapContentSize(Alignment.TopCenter)//位置 位于 底部 开始（左）Modifier.wrapContentSize(Alignment.BottomStart)//位置 位于 底部 结束（右）Modifier.wrapContentSize(Alignment.BottomEnd)//位置 位于 底部 水平居中Modifier.wrapContentSize(Alignment.BottomCenter)//位置 位于 垂直居中 开始（左）Modifier.wrapContentSize(Alignment.CenterStart)//位置 位于 垂直居中 结束（右）Modifier.wrapContentSize(Alignment.CenterEnd)]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 LazyRow]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20LazyRow%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- LazyRow 延迟 水平 布局 LazyRow 延迟 水平 布局 简单使用 123456789101112131415161718192021222324252627282930313233@Composable fun LazyRowDemo() &#123; val list = listOf("A", "B", "C", "D") + ((0..20).map &#123; it.toString() &#125;) LazyRow(Modifier.fillMaxHeight()) &#123; items( key = &#123; list.get(it) &#125;, count = list.size, itemContent = &#123; item -&gt; val content = list.get(item) Log.d("COMPOSE", "This get rendered $&#123;content&#125;") when (content) &#123; "A" -&gt; &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; "B" -&gt; &#123; Button(onClick = &#123;&#125;) &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; &#125; "C" -&gt; &#123; &#125; "D" -&gt; &#123; Text(text = content) &#125; else -&gt; &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; &#125; &#125; ) &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 LazyColumn]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20LazyColumn%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- LazyColumn 延迟 垂直 布局 LazyColumn 延迟 垂直 布局 简单使用 123456789101112131415161718192021222324252627282930313233 @Composablefun LazyColumnDemo() &#123; val list = listOf("A", "B", "C", "D") + ((0..20).map &#123; it.toString() &#125;) LazyColumn(Modifier.fillMaxWidth()) &#123; items( key = &#123; list.get(it) &#125;, count = list.size, itemContent = &#123; item -&gt; val content = list.get(item) Log.d("COMPOSE", "This get rendered $&#123;content&#125;") when (content) &#123; "A" -&gt; &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; "B" -&gt; &#123; Button(onClick = &#123;&#125;) &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; &#125; "C" -&gt; &#123; &#125; "D" -&gt; &#123; Text(text = content) &#125; else -&gt; &#123; Text(text = content, style = TextStyle(fontSize = 80.sp)) &#125; &#125; &#125; ) &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Image Icon]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Image%20Icon%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- 图片 Image , Icon Image 图片 基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Composablefun ImageResourceDemo() &#123; val image = painterResource(id = R.mipmap.icon_header) Column &#123; Image( painter = image, contentDescription = "图片描述" ) Image( painter = image, contentDescription = "图片描述", //设置图片大小 modifier = Modifier.size(100.dp) ) Surface( //设置形状 shape = CircleShape ) &#123; Image( painter = image, contentDescription = "图片描述", //设置图片大小 modifier = Modifier.size(100.dp), //保持宽高比缩放 contentScale = ContentScale.Crop ) &#125; Surface( //设置形状 shape = CircleShape, //边框 border = BorderStroke(2.dp, Color.Gray), ) &#123; Image( painter = image, contentDescription = "图片描述", //设置图片大小 modifier = Modifier.size(100.dp), //保持宽高比缩放 contentScale = ContentScale.Crop ) &#125; &#125;&#125; Icon 基本使用 12345678910111213@Composablefun ComposableSample() &#123; Row &#123; Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.Gray) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.Red) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.DarkGray) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.Magenta) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.Cyan) Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = null, tint = Color.Blue) &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 DropdownMenu]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20DropdownMenu%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- DropdownMenu 下拉菜单 DropdownMenu 下拉菜单 基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Composablefun DropdownSample() &#123; val isExpanded = remember &#123; mutableStateOf(false) &#125; val list = listOf("A", "B", "C", "D", "E", "F", "G") val disabledValue = "B" var selectedIndex = remember &#123; mutableStateOf(0) &#125; Box( modifier = Modifier .fillMaxSize() .wrapContentSize(Alignment.TopStart) ) &#123; Text( text = list[selectedIndex.value], modifier = Modifier .fillMaxWidth() .height(30.dp) .padding(10.dp) .clickable &#123; isExpanded.value = true &#125; .background( Color.Black ), color = Color.White ) DropdownMenu( expanded = isExpanded.value, onDismissRequest = &#123; isExpanded.value = false &#125;, modifier = Modifier .fillMaxWidth() .background(Color.Red) ) &#123; list.forEachIndexed &#123; index, s -&gt; DropdownMenuItem(onClick = &#123; selectedIndex.value = index isExpanded.value = false &#125; ) &#123; val disaledText = if (disabledValue == s) &#123; " (Disabled)" &#125; else &#123; "" &#125; Text(text = "$&#123;s&#125;$&#123;disaledText&#125;") &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Crossfade]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Crossfade%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Crossfade Crossfade 动画 淡入淡出 123456789101112131415161718192021222324252627282930313233343536373839404142enum class MyColors(val color: Color) &#123; Red(Color.Red), Green(Color.Green), Blue(Color.Blue),&#125;//淡入淡出 动画@Composablefun CrossfadeDemo() &#123; var currentColor = remember &#123; mutableStateOf(MyColors.Red) &#125; Column &#123; Row &#123; MyColors.values().forEach &#123; myColors -&gt; Button( onClick = &#123; currentColor.value = myColors &#125;, Modifier.weight(1f, true) .height(48.dp) .background(myColors.color), colors = ButtonDefaults.buttonColors( backgroundColor = myColors.color ) ) &#123; Text(myColors.name, color = Color.White) &#125; &#125; &#125; //淡入淡出 切换动画 Crossfade( targetState = currentColor, animationSpec = tween(3000) ) &#123; selectedColor -&gt; Box( modifier = Modifier .fillMaxSize() .background(color = selectedColor.value.color) ) &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Column Row Box Spacer BoxWithConstraints ConstraintLayout]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Column%20Row%20Box%20Spacer%20BoxWithConstraints%20ConstraintLayout%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- 布局 Column Row Box Spacer BoxWithConstraints ConstraintLayout Column 垂直布局（将多个项垂直地放置在屏幕上） 12345678@Composable fun ColumnLayoutDemo() &#123; //垂直布局 Column &#123; Text(text = "Alfred Sisley") Text(text = "3 minutes ago") &#125; &#125; 12345678910111213@Composablefun ComposableSample() &#123; //文字居中 Column( Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally ) &#123; Text("你好呀") Text("我正在使用 Android Studio") Text("现在是晚上") &#125;&#125; 1234567891011121314151617@Composablefun ComposableSample() &#123; //特定文字居中 Column( Modifier.fillMaxWidth(), ) &#123; Text( text = "夜色", //特定文字居中 modifier = Modifier.align(Alignment.CenterHorizontally), style = MaterialTheme.typography.h6, fontWeight = FontWeight.W900 ) Text("今晚的夜色很不错，我和朋友走在河边的小路上，看到了很多美丽的风景") &#125;&#125; Row 水平布局 （将多个项水平地放置在屏幕上） 12345678910111213141516 @Composablefun RowLayoutDemo() &#123; //水平布局 Row(verticalAlignment = Alignment.CenterVertically) &#123; //图片 Image( painter = painterResource(id = R.mipmap.icon_header), contentDescription = null ) //垂直布局 Column &#123; Text(text = "Alfred Sisley") Text(text = "3 minutes ago") &#125; &#125;&#125; 12345678910111213141516@Preview @Composable fun AlignInRowDemo() &#123; Row( modifier = Modifier .size(150.dp) .background(Color.Gray), //水平排列 horizontalArrangement = Arrangement.End, //垂直排列 verticalAlignment = Alignment.CenterVertically, ) &#123; Box(Modifier.size(50.dp).background(Color.Yellow)) Box(Modifier.size(50.dp).background(Color.Blue)) &#125; &#125; 123456789@Composablefun ComposableSample() &#123; Row &#123; Box(Modifier.size(40.dp).background(Color.Magenta)) Box(Modifier.size(40.dp).background(Color.Yellow)) Box(Modifier.size(40.dp).background(Color.Green)) &#125;&#125; 1234567891011121314151617181920212223@Composablefun ComposableSample() &#123; Row &#123; Box( Modifier .size(40.dp) //权重 .weight(1f) .background(Color.Magenta) ) Box( Modifier .size(40.dp) .background(Color.Yellow)) Box( Modifier .size(40.dp) //权重 .weight(1f) .background(Color.Green)) &#125;&#125; Box 水平布局 （将一个元素放在另一个元素上） 1234567@Composable fun BoxLayoutDemo() &#123; Box() &#123; Text(text = "测试", color = Color.Blue, fontSize = 15.sp) Text(text = "测试", color = Color.Yellow, fontSize = 30.sp) &#125; &#125; Spacer 空白布局 123456789101112131415161718192021222324@Composablefun ComposableSample() &#123; Row &#123; Box( Modifier .size(100.dp) .background(Color.Magenta) ) //空白布局 Spacer(modifier = Modifier.width(20.dp)) Box( Modifier .size(100.dp) .background(Color.Yellow) ) Spacer(modifier = Modifier.weight(1f)) Box( Modifier .size(100.dp) .background(Color.Green) ) &#125;&#125; 12345678910111213141516171819202122@Composablefun ArtistCardDemo() &#123; val padding = 16.dp Column( Modifier .clickable(onClick = &#123; Log.d("Clickable", " clicked.") &#125;) .padding(padding) .fillMaxWidth() ) &#123; RowLayoutDemo() Spacer(Modifier.size(padding)) Card(elevation = 4.dp) &#123; Image( painter = painterResource(id = R.mipmap.icon_header), contentDescription = null ) &#125; &#125;&#125; 12345678910111213 //内边距@Composablefun PaddedComposableDemo() &#123; Text( text="Hello World", modifier = //背景 Modifier.background(Color.Green) //内边距 .padding(20.dp))&#125; 12345678910//设置尺寸 @Composable fun SizedComposableDemo() &#123; Box( //设置尺寸 modifier = Modifier.size(100.dp, 100.dp) //背景 .background(Color.Red)) &#125; 12345678910111213141516171819@Composable fun FixedSizeComposableDemo() &#123; Box( modifier = Modifier //设置尺寸 .size(90.dp, 150.dp) //背景 .background(Color.Blue) ) &#123; //设置所需尺寸 Box( Modifier .requiredSize(120.dp, 120.dp) //背景 .background(Color.Red) ) &#125; &#125; 1234567891011121314151617181920@Composablefun FillSizeComposableDemo() &#123; Box( Modifier //背景 .background(Color.Green) //尺寸 .size(50.dp) //内边距 .padding(10.dp) ) &#123; Box( Modifier //背景 .background(Color.Blue) //填充 最大边距 .fillMaxSize() ) &#125;&#125; 1234567891011121314 @Composable fun MatchParentSizeComposable() &#123; Box &#123; Spacer( modifier = Modifier // 仅在 Box 作用域内可用 .matchParentSize() //Spacer 将占用父项允许的所有可用空间，反过来使父项展开并填满所有可用空间// .fillMaxSize() .background(Color.Green) ) Text(text = "Hello World") &#125; &#125; 123456789101112//在文本基线上方添加内边距 @Composable fun TextWithPaddingFromBaseline() &#123; Box(modifier = Modifier.background(Color.Green)) &#123; Text( text = "Hello World", modifier = Modifier //在文本基线上方添加内边距 .paddingFromBaseline(top = 20.dp, bottom = 5.dp) ) &#125; &#125; 123456789101112131415//偏移量@Composablefun OffsetComposable() &#123; Box( modifier = Modifier .size(width = 160.dp, height = 80.dp) .background(Color.Blue) ) &#123; Text( text = "Layout offset modifier sample", //偏移量 Modifier.offset(x = 16.dp, y = 40.dp) ) &#125;&#125; 123456789101112131415161718//自适应布局@Composablefun FlexibleComposable() &#123; Row(Modifier.width(200.dp)) &#123; Box( modifier = Modifier .weight(1f) .height(30.dp) .background(Color.Green) ) Box( modifier = Modifier .weight(3f) .height(30.dp) .background(Color.Red) ) &#125;&#125; BoxWithConstraints 12345678//约束条件 @Composable fun WithConstraintsComposable() &#123; //约束条件 BoxWithConstraints &#123; Text("My minHeight is $minHeight while my maxWidth is $maxWidth") &#125; &#125; 123456789101112131415161718192021222324252627@Composablefun ComposableSample() &#123; BoxWithConstraints( modifier = Modifier.fillMaxWidth(), //内容的对齐方式 contentAlignment = Alignment.TopStart, //是否将约束作用于 子 View 上 propagateMinConstraints = true, ) &#123; val itemW = 50.dp val spaceW = 2.dp val count = (maxWidth.value / (itemW.value + spaceW.value)).toInt() if (count &gt; 0) &#123; Row() &#123; for (i in 0 until count) &#123; Box( Modifier .size(itemW, itemW) .background(Color.Blue) ) Spacer(Modifier.size(spaceW)) &#125; &#125; &#125; &#125;&#125; ConstraintLayout 约束布局 12345678910111213141516171819@Composablefun ConstraintLayoutDemo() &#123; ConstraintLayout &#123; //通过 createRefs() 或 createRefFor() 创建关联的引用 val (text1,text2,text3) = createRefs() //使用 constrainAs() 修饰符提供的约束条件 Text(text = "Text1", Modifier.constrainAs(text1) &#123; //指定约束条件 start.linkTo(text2.end) &#125;) Text(text = "Text2", Modifier.constrainAs(text2) &#123; top.linkTo(text1.bottom) &#125;) Text(text = "This is a very long text", Modifier.constrainAs(text3) &#123; start.linkTo(text2.end) top.linkTo(text2.bottom) &#125;) &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 CircularProgressIndicator]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20CircularProgressIndicator%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- CircularProgressIndicator 圆形进度条 CircularProgressIndicator 圆形进度条 基本使用 12345678910111213141516171819202122232425262728293031323334353637 @Composablefun CircularProgressIndicatorSample() &#123; var progress = remember &#123; mutableStateOf(0.0f) &#125; val animatedProgress = animateFloatAsState( targetValue = progress.value, animationSpec = ProgressIndicatorDefaults.ProgressAnimationSpec ).value Column(horizontalAlignment = Alignment.CenterHorizontally) &#123; Spacer(modifier = Modifier.height(30.dp)) Text(text = "进度 不确定 的 圆形 进度条") Spacer(modifier = Modifier.height(30.dp)) CircularProgressIndicator() Spacer(modifier = Modifier.height(30.dp)) Text(text = "圆形进度条 进度通过 点击按钮 添加") Spacer(modifier = Modifier.height(30.dp)) CircularProgressIndicator(progress = animatedProgress) Spacer(modifier = Modifier.height(30.dp)) OutlinedButton(onClick = &#123; if (progress.value &lt; 1f) &#123; progress.value += 0.1f &#125; &#125;) &#123; Text(text = "添加进度") &#125; Spacer(modifier = Modifier.height(30.dp)) OutlinedButton(onClick = &#123; if (progress.value &gt; 0f) &#123; progress.value -= 0.1f &#125; &#125;) &#123; Text(text = "降低进度") &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Checkbox]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Checkbox%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Checkbox 复选框 Checkbox 复选框 基本使用 12345678910111213@Composablefun CheckBoxDemo() &#123; val checkedState = remember &#123; mutableStateOf(true) &#125; Checkbox( checked = checkedState.value, onCheckedChange = &#123; checkedState.value = it &#125; )&#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Card]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Card%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Card Card 卡片 简单使用 12345678910@Composable fun CardDemo() &#123; Card( modifier = Modifier.fillMaxWidth() , backgroundColor = Color.White, elevation = 10.dp, ) &#123; Text(text = "This is a Card Demo",Modifier.padding(10.dp)) &#125; &#125; 123456789101112131415161718192021222324252627@Composablefun ComposableSample() &#123; Card( modifier = Modifier .size(200.dp) .padding(10.dp), //形状 圆角矩形 shape = RoundedCornerShape(8.dp), //背景颜色 backgroundColor = Color.White, //内容的颜色 contentColor = Color.Black, //边框 border = BorderStroke(0.5.dp, Color.Gray), //阴影 elevation = 10.dp ) &#123; Column() &#123; Image( painter = painterResource(id = R.mipmap.icon_header), contentDescription = "图片描述", contentScale = ContentScale.FillBounds ) &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Composable fun CardDemo() &#123; Card( modifier = Modifier .fillMaxWidth() // 外边距 .padding(15.dp) .clickable( // 设置点击波纹效果，注意如果 CardDemo() 函数不在 ExamplesTheme() &#123;&#125; 下调用 // 将无法显示波纹效果 onClick = &#123; Log.d("Clickable", " clicked.") &#125;), backgroundColor = Color.White, // 设置阴影 elevation = 10.dp, ) &#123; Column( // 内边距 Modifier.padding(15.dp) ) &#123; Text(buildAnnotatedString &#123; append("welcome to ") withStyle( style = SpanStyle( color = Color(0xFF4552B8), fontWeight = FontWeight.W900, ) ) &#123; append("Jetpack Compose Playground") &#125; &#125;) Text(buildAnnotatedString &#123; append("Now you are in the ") withStyle( style = SpanStyle( fontWeight = FontWeight.W900, ) ) &#123; append("Card") &#125; append(" section") &#125;) &#125; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Canvas]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Canvas%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- Canvas 图形 Canvas 图形 基本属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//绘制 线 @Composable fun CanvasDrawLineDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasWidth = size.width val canvasHeight = size.height //绘制 线 drawLine( start = Offset(x = canvasWidth, y = 0f), end = Offset(x = 0f, y = canvasHeight), color = Color.Red ) &#125; &#125; //绘制 圆 @Composable fun CanvasDrawCircleDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasWidth = size.width val canvasHeight = size.height //绘制 圆 drawCircle( color = Color.Red, //圆心 画布中心点 center = Offset( x = canvasWidth / 2, y = canvasHeight / 2 ), //半径 : 画布最小边 的 1/4 radius = size.minDimension / 4 ) &#125; &#125;//绘制 弧@Composablefun CanvasDrawArcDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; //绘制 弧 drawArc( color = Color.Red, startAngle = 0f, sweepAngle = 60f, useCenter = true, size = Size(300f, 300f), topLeft = Offset(60f, 60f) ) &#125;&#125; //绘制 矩形 @Composable fun CanvasDrawRectDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasQuadrantSize = size / 2f //绘制 矩形 drawRect( color = Color.Red, size = canvasQuadrantSize ) &#125; &#125; //绘制 矩形 @Composable fun CanvasInsetDrawRectDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasQuadrantSize = size / 2f //更改绘图边界 inset(150f, 30f) &#123; //绘制 矩形 drawRect( color = Color.Red, size = canvasQuadrantSize ) &#125; &#125; &#125; //绘制 矩形 @Composable fun CanvasDrawRectTopLeftDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasWidth = size.width val canvasHeight = size.height val canvasSize = size //绘制 矩形 drawRect( color = Color.Red, topLeft = Offset(x = canvasWidth / 3f, y = canvasHeight / 3f), size = canvasSize / 3f ) &#125; &#125; //绘制 矩形 @Composable fun CanvasRotateDrawRectDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; //旋转 45 度 rotate(degrees = 45f) &#123; val canvasWidth = size.width val canvasHeight = size.height val canvasSize = size //绘制 矩形 drawRect( color = Color.Red, topLeft = Offset(x = canvasWidth / 3f, y = canvasHeight / 3f), size = canvasSize / 3f ) &#125; &#125; &#125; //绘制 矩形 @Composable fun CanvasTransformDrawRectDemo() &#123; //画布 Canvas( //充满整个屏幕 modifier = Modifier.fillMaxSize() ) &#123; val canvasWidth = size.width val canvasHeight = size.height val canvasSize = size //多种转换 withTransform(&#123; //平移 translate(left = canvasWidth / 5f) //旋转 45 度 rotate(degrees = 45f) &#125;) &#123; //绘制 矩形 drawRect( color = Color.Red, topLeft = Offset(x = canvasWidth / 3f, y = canvasHeight / 3f), size = canvasSize / 3f ) &#125; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 Button IconButton]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20Button%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- 按钮 Button , IconButton Button 按钮 基本使用 12345678910111213@Composablefun ButtonSample() &#123; Button( onClick = &#123; Log.d("ButtonSample", "按钮被点击") &#125;, modifier = Modifier.padding(10.dp), colors = ButtonDefaults.textButtonColors(backgroundColor = Color.Blue) ) &#123; Text(text = "按钮", color = Color.White) &#125;&#125; 1234567891011121314@Composablefun ComposableSample() &#123; Button(onClick = &#123; &#125;) &#123; Icon( imageVector = Icons.Filled.Favorite, contentDescription = "喜爱", modifier = Modifier.size(ButtonDefaults.IconSize) ) //间隔 Spacer(modifier = Modifier.size(ButtonDefaults.IconSpacing)) Text(text = "喜爱") &#125;&#125; IconButton 图标按钮 基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Composablefun ComposableSample() &#123; Row &#123; IconButton(onClick = &#123; &#125;) &#123; Icon(Icons.Filled.Search, null) &#125; IconButton(onClick = &#123; &#125;) &#123; Icon(Icons.Filled.ArrowBack, null) &#125; IconButton(onClick = &#123; &#125;) &#123; Icon(Icons.Filled.Done, null) &#125; val isSelected = remember &#123; mutableStateOf(false) &#125; //取消水波纹 IconButtonNoIndication(onClick = &#123; isSelected.value = !isSelected.value &#125;) &#123; Icon( Icons.Filled.Home, null, tint = if (isSelected.value) &#123; Color.Red &#125; else &#123; Color.Gray &#125; ) &#125; &#125;&#125; /** * 去掉水波纹 */ @Composable fun IconButtonNoIndication( onClick: () -&gt; Unit, modifier: Modifier = Modifier, enabled: Boolean = true, interactionSource: MutableInteractionSource = remember &#123; MutableInteractionSource() &#125;, content: @Composable () -&gt; Unit ) &#123; Box( modifier = modifier .clickable( onClick = onClick, enabled = enabled, role = Role.Button, interactionSource = interactionSource, //取消水波纹 indication = null ) .then(Modifier.size(48.dp)), contentAlignment = Alignment.Center ) &#123; content() &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose学习 AlertDialog]]></title>
    <url>%2F2021%2F05%2F25%2FJetpack%20Compose%2FJetpack%20Compose%20AlertDialog%2F</url>
    <content type="text"><![CDATA[Jetpack Compose学习 -------- AlertDialog AlertDialog 提示框 简单使用 12345678910111213141516171819202122232425262728293031323334353637383940414243@Composablefun AlertDialogSample() &#123; MaterialTheme &#123; Column( Modifier .fillMaxSize() .wrapContentSize(Alignment.Center) ) &#123; val openDialog = remember &#123; mutableStateOf(false) &#125; Button(onClick = &#123; openDialog.value = true &#125;) &#123; Text(text = "弹出提示框") &#125; if (openDialog.value) &#123; AlertDialog( onDismissRequest = &#123; // 当用户点击对话框以外的地方或者按下系统返回键将会执行的代码 openDialog.value = false &#125;, title = &#123; Text(text = "提示框标题") &#125;, text = &#123; Text(text = "提示框内容") &#125;, confirmButton = &#123; Button(onClick = &#123; openDialog.value = false &#125;) &#123; Text(text = "确认按钮") &#125; &#125;, dismissButton = &#123; Button(onClick = &#123; openDialog.value = false &#125;) &#123; Text(text = "取消按钮") &#125; &#125;) &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Composablefun AlertDialogSample2() &#123; MaterialTheme &#123; Column( Modifier .fillMaxSize() .wrapContentSize(Alignment.Center) ) &#123; val openDialog = remember &#123; mutableStateOf(false) &#125; Button(onClick = &#123; openDialog.value = true &#125;) &#123; Text(text = "弹出提示框") &#125; if (openDialog.value) &#123; AlertDialog( onDismissRequest = &#123; // 当用户点击对话框以外的地方或者按下系统返回键将会执行的代码 openDialog.value = false &#125;, title = &#123; Text( text = "开启位置服务", fontWeight = FontWeight.W700, style = MaterialTheme.typography.h6 ) &#125;, text = &#123; Text( text = "这将意味着，我们会给您提供精准的位置服务，并且您将接受关于您订阅的位置信息", fontSize = 16.sp ) &#125;, confirmButton = &#123; TextButton( onClick = &#123; openDialog.value = false &#125;, ) &#123; Text( "确认", fontWeight = FontWeight.W700, style = MaterialTheme.typography.button ) &#125; &#125;, dismissButton = &#123; TextButton( onClick = &#123; openDialog.value = false &#125; ) &#123; Text( "取消", fontWeight = FontWeight.W700, style = MaterialTheme.typography.button ) &#125; &#125;) &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Composable fun AlertDialogSample3() &#123; MaterialTheme &#123; Column( Modifier .fillMaxSize() .wrapContentSize(Alignment.Center) ) &#123; val openDialog = remember &#123; mutableStateOf(false) &#125; Button(onClick = &#123; openDialog.value = true &#125;) &#123; Text(text = "弹出提示框") &#125; if (openDialog.value) &#123; AlertDialog( onDismissRequest = &#123; openDialog.value = false &#125;, title = &#123; Text( text = "开启位置服务", fontWeight = FontWeight.W700, style = MaterialTheme.typography.h6 ) &#125;, text = &#123; Text( text = "这将意味着，我们会给您提供精准的位置服务，并且您将接受关于您订阅的位置信息", fontSize = 16.sp ) &#125;, buttons = &#123; Row( modifier = Modifier.padding(all = 8.dp), horizontalArrangement = Arrangement.Center ) &#123; Button( modifier = Modifier.fillMaxWidth(), onClick = &#123; openDialog.value = false &#125; ) &#123; Text("必须接受！") &#125; &#125; &#125; ) &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Jetpack Compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Play应用上架流程]]></title>
    <url>%2F2020%2F11%2F18%2Fother%2F%E4%B8%8A%E4%BC%A0%E5%BA%94%E7%94%A8%E8%87%B3Google%20Play%2F</url>
    <content type="text"><![CDATA[Google Play应用上架流程 注册开发者账号 创建应用 选择默认语言 （最好选择英语），填写应用名称 商品详情（默认选中） 需要填写 App简介和详细描述内容（需要和默认语言一致） 上传APP图片（屏幕截图、高分辨率图标、置顶大图） 选择应用类型和类别 填写公司官网，联系邮箱（邮箱地址会展示给用户，不要乱填），内容分级（可以先不管，在上传App后才能进行分级判断），电话（填写公司电话，会展示给用户），隐私权政策。 上传正式版应用（商品版本: 正式版、Beta版、Alpha版本） 创建版本 加入 Google Play App Signing 上传APK安装包 填写版本说明 内容分级 填写电子邮件地址（用来接收Google Play发送的消息），选择应用类别 调查问卷页 （基本上都选择否）点击 判断分级 确认分级 定价和分发范围 注意 “ 国家/地区 ” 默认是 0，需要自己选择国家 内容准则 和 美国出口法律 是必须要选中的，最后点击 “ 保存草稿 ” 应用发布 如果所有内容都填写正确，我们会看到左边导航栏4个绿色对勾，并且出现“可以发布”按钮 点击左边导航栏中的 &quot; 应用版本 &quot; 点击 “ 修改版本 ” 点击 “ 查看 ” , 确认没有问题后，点击 “ 开始发布正式版 ”，就可以发布了，然后就需要审核了 查看审核进度]]></content>
      <categories>
        <category>应用上架</category>
      </categories>
      <tags>
        <tag>Google Play</tag>
        <tag>应用上架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FileUtils帮助类]]></title>
    <url>%2F2020%2F07%2F02%2Fandroid%2FFileUtils%E5%B8%AE%E5%8A%A9%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[FileUtils帮助类 在AndroidUtilCode的基础下使用 将assets文件夹中的内容写入本地 123456789101112131415161718192021222324/** * 将assets文件夹中的内容写入本地 * @param dirName String 文件夹名称 * @param fileName String 文件名称及后缀名 * @return String? SDCard/Android/data/应用包名/files/ 目录/文件 */ private suspend fun getExternalFilePath(dirName: String, fileName: String): String? = withContext(Dispatchers.IO) &#123; //创建文件夹 val mFileDir = Utils.getApp().applicationContext.getExternalFilesDir(dirName) if (mFileDir != null) &#123; //创建文件 val mFilePath: String = File(mFileDir, fileName).absolutePath if (FileUtils.isFileExists(mFilePath)) &#123; return@withContext mFilePath //将assets文件夹中的内容写入本地 &#125; else if (ResourceUtils.copyFileFromAssets(fileName, mFilePath)) &#123; return@withContext mFilePath &#125; else &#123; return@withContext null &#125; &#125; return@withContext null &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频时长(Long)转字符串(String)_Java]]></title>
    <url>%2F2020%2F07%2F02%2Fandroid%2F%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF(Long)%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2(String)_Java%2F</url>
    <content type="text"><![CDATA[视频时长(Long)转字符串(String)_Java 1234567891011121314151617181920212223242526/** * 时长转字符 * @param mDuration 时长（毫秒） * @param isMillisecond 是否需要毫秒，true:需要，false:不用 * @return */ public static String getTimeDurationString(@NonNull Long mDuration, @NonNull Boolean isMillisecond) &#123; Long hours = 0L, minutes = 0L, seconds = 0L, millisecond = null; if (isMillisecond) &#123; //毫秒 millisecond = mDuration % TimeConstants.SEC; &#125; hours = mDuration / TimeConstants.HOUR; minutes = (mDuration / TimeConstants.MIN)-(hours*60); seconds = (mDuration / TimeConstants.SEC)-(minutes*60)-(hours*3600); String str_duration = getTimeString(hours, minutes, seconds, millisecond); return str_duration; &#125; private static String getTimeString(@NonNull Long hours, @NonNull Long minutes, @NonNull Long seconds, Long millisecond) &#123; if (millisecond != null) &#123; return String.format(&quot;%02d:%02d:%02d.%02d&quot;, hours, minutes, seconds, millisecond); &#125; else &#123; return String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds); &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg常用命令]]></title>
    <url>%2F2020%2F06%2F29%2Fffmpeg%2FFFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[FFmpeg常用命令 改变帧率，码率和文件大小 帧率 12//改变视频 input.mp4 的帧率，生成帧率为30的新视频 output.mp4ffmpeg -i input.mp4 -r 30 output.mp4 码率 12//改变视频 input.mp4 的帧率，生成码率为 1.5 Mb/s(兆比特)的新视频 output.mp4ffmpeg -i input.mp4 -b 1.5M output.mp4 最大输出文件大小 12//改变视频 input.mp4 的文件大小，生成文件大小为10MB的新视频 output.mp4ffmpeg -i input.mp4 -fs 10MB output.mp4 调整视频分辨率 分辨率：w*h （w:像素宽度，h:像素高度） 1234567891011//改变视频 input.mp4 的分辨率，生成分辨率为320*240的新视频 output.mp4ffmpeg -i input.mp4 -s 320*240 output.mp4//改变视频 input.mp4 的分辨率(使用 scale filter 替代 -s )，生成分辨率为 320*240 的新视频 output.mp4ffmpeg -i input.mp4 -vf scale=320:240 output.mp4//改变视频 input.mp4 的分辨率，生成分辨率为640*480的新视频 output.mp4ffmpeg -i input.mp4 -s 640*480 output.mp4//改变视频 input.mp4 的分辨率，生成分辨率为 vga (640*480)的新视频 output.mp4ffmpeg -i input.mp4 -s vga output.mp4 裁剪、填充视频 视频裁剪 1234567891011//裁剪矩形框---靠左1/3ffmpeg -i input.mp4 -vf crop=iw/3:ih:0:0 output.mp4//裁剪矩形框---靠中1/3ffmpeg -i input.mp4 -vf crop=iw/3:ih:iw/3:0 output.mp4//裁剪矩形框---靠右1/3ffmpeg -i input.mp4 -vf crop=iw/3:ih:iw/3*2:0 output.mp4//裁剪中间的一半(默认从输入视频的中间区域开始)ffmpeg -i input.mp4 -vf crop=iw/2:ih/2 output.mp4 视频填充 12345678910//改变视频的宽高比(4:3)，生成宽高比为16:9的新视频 ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output//改变视频的宽高比(4:3)，生成宽高比为16:9的新视频(颜色默认:黑色) ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0 output//改变视频的宽高比(16:9)，生成宽高比为4:3的新视频 ffmpeg -i input -vf pad=iw:iw*3/4:0:(oh-ih)/2:0:color outputffmpeg -i input -vf pad=iw:iw*3/4:0:(oh-ih)/2:0 output 翻转、旋转视频 视频翻转 12345//水平翻转ffplay -f lavfi -i testsrc -vf hflip//垂直翻转ffplay -f lavfi -i testsrc -vf vflip 视频旋转 参数：transpose 0 : 逆时针方向旋转90° 并且垂直翻转 1 : 顺时针方向旋转90° 2 : 逆时针方向旋转90° 3 : 顺时针方向旋转90° 并且垂直翻转 1234567891011//逆时针方向旋转90° 并且垂直翻转ffmpeg -i input.mp4 -vf transpose=0 output.mp4//顺时针方向旋转90° ffmpeg -i input.mp4 -vf transpose=1 output.mp4//逆时针方向旋转90° ffmpeg -i input.mp4 -vf transpose=2 output.mp4//顺时针方向旋转90° 并且垂直翻转ffmpeg -i input.mp4 -vf transpose=3 output.mp4 模糊、锐化视频 模糊视频 12345//模糊视频 input.mp4 ，生成一个luma半径为1.5,luma权值为1的新视频 output.mp4ffmpeg -i input.mp4 -vf boxblur=1.5:1 output.mp4//模糊视频 input.mp4 ，生成一个luma半径为1,luma亮度为0.8,亮度阈值为0的新视频 output.mp4 (不影响图像的轮廓,使用smartblur滤波器处理)ffmpeg -i input.mp4 -vf smartblur=5:0.8:0 output.mp4 锐化视频 (unsharp 滤波器) 1234567891011//锐化视频 input.mp4 ，生成一个新视频 output.mp4ffmpeg -i input.mp4 -vf unsharp output.mp4//锐化视频 input.mp4 ，生成一个 5*5的矩形luma 强度为 1 色度值为-2 的新视频 output.mp4ffmpeg -i input.mp4 -vf unsharp=6:6:-2 output.mp4//增强去噪 (denoise3d视频滤波器)ffmpeg -i input.mp4 -vf mp=denoise3d output.mp4//视频降噪 (hqdn3d过滤器)ffmpeg -i input.mp4 -vf hqdn3d output.mp4 画中画 123456789101112131415161718192021222324252627282930//视频叠加 input1:视频背景,input2:前景图ffmpeg -i input1 -i input2 -filter_complex overlay=x:y outputffmpeg -i input1 -vf movie=input2[logo];[in][logo]overlay=x:y output//视频 input.mp4 添加logo到视频左上角，生成新视频 output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4//视频 input.mp4 添加logo到视频右上角，生成新视频 output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4//视频 input.mp4 添加logo到视频右下角，生成新视频 output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4//视频 input.mp4 添加logo到视频左下角，生成新视频 output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4//视频 input.mp4 添加logo(5s后显示)，生成新视频 output.mp4ffmpeg -i input.mp4 -itsoffset 5 -i logo.png -filter_complex overlay output.mp4//视频 input.mp4 添加计时器，生成新视频 output.mp4//生成计时器ffmpeg -f lavfi -i testsrc -vf crop=61:52:224:94 -t 142 timer.ogg//添加计时器到视频中ffmpeg -i input.mp4 -i timer.ogg -filter_complex overlay=451 output.mp4//添加计时器到视频中(将计时器缩小到原来的1/2,并放到底部)ffmpeg -i input.mp4 -vf movie=timer.ogg,scale=15:14[tm];[in][tm] overlay=248:371 output.mp4 在视频上添加文字 1234567891011121314151617181920212223242526//字体文件(arial.ttf)复制到当前目录下ffplay -f lavfi -i color=c=white -vf drawtext=fontfile=arial.ttf:text=Welcome//文字位置(x:水平方向,y:垂直方向)//tw:文本宽度,w:帧宽,(w-tw)/2:水平居中,w-tw:文本对齐到右边//th:文本高度,w:帧高,(h-th)/2:垂直居中,h-th:文本对齐到底部//drawtext(滤镜):如果其中有空格,将包含在成对单引号或成对双引号中ffplay -f lavfi -i color=c=white -vf drawtext=&quot;fontfile=arial.ttf:text=&apos;hello world&apos;:x=(w-tw)/2:y=(h-th)/2&quot;//fontcolor:文字颜色,fontsize:文字大小,color:背景颜色//背景色:蓝色,字体颜色:黄色,字体大小:30ffplay -f lavfi -i color=c=blue -vf drawtext=&quot;fontfile=arial.ttf:text=&apos;hello world&apos;:x=(w-tw)/2:y=(h-th)/2:fontcolor=yellow:fontsize=30&quot;//水平方向上的文字运动//t:时间(单位:s),n:移动像素//从右往左方向向上移动,每秒移动n个像素: x = w - t*n//从左往右方向向上移动,每秒移动n个像素: x = w + t*n//顶部移动ffmpeg -f lavfi -i color=c=blue -vf drawtext=&quot;fontfile=arial.ttf:text=&apos;hello world&apos;:x=w-t*50:fontcolor=yellow:fontsize=30&quot; output//底部滚动ffmpeg -f lavfi -i color=c=blue -vf drawtext=&quot;fontfile=arial.ttf:textfile=info.txt:x=w-t*50:y=h-th:fontcolor=yellow:fontsize=30&quot; output//垂直方向文字滚动ffmpeg -i input.mp4 -vf drawtext=&quot;fontfile=arial.ttf:textfile=Credits:x=(w-tw)/2:y=h-t*100:fontcolor=white:fontsize=30&quot; output.mp4 视频文件格式转化 格式（视频） 编解码器 其他数据 .avi mpeg4 mpeg4 (Simple profile), yuv420p; audio: mp3 .flv flv1 yuv420p; audio: mp3 .mkv h264 h264 (High), yuvj420p; audio: vorbis codec, fltp sample format .mov h264 h264 (High), yuvj420p; audio: aac (mp4a) .mp4 h264 h264 (High), yuvj420p; audio: aac (mp4a) .mpg mpeg1video yuv420p; audio: mp2 .ogg theora yuv422p, bitrate very low; audio excluded during conversion .ts mpeg2video yuv422p; audio: mp2 .webm vp8 yuv420p; audio: vorbis codec, fltp sample format 格式(音频) 编解码器 其他数据 .aac aac libvo_aacenc, bitrate 128 kb/s .flac flac FLAC (Free Lossless Audio Codec), bitrate 128 kb/s .m4a aac mp4a, bitrate 128 kb/s .mp2 mp2 MPEG Audio Layer 2, bitrate 128 kb/s .mp3 mp3 libmp3lame, bitrate 128 kb/s .wav pcm_s16le PCM (Pulse Code Modulation), uncompressed .wma wmav2 Windows Media Audio 重写相同命名的输出文件 1ffmpeg -y -i input.avi output.mp4 时间操作 12345678910111213//通过视频 input.mp4 ，生成一个时长为120s的新视频 output.mp4ffmpeg -i input.mp4 -t 120 output.mp4//通过视频 input.mp4 ，生成一个时长为30s帧率为25的新视频 output.mp4ffmpeg -i input.mp4 -t 30 -r 25 output.mp4//设置一个10分钟25fps的视频ffmpeg -i video.avi -vframes 15000 video_10_minute.avi//设置延迟转换 (从10s开始进行转换)ffmpeg -i input.avi -ss 10 output.mp4//提取媒体文件中部分内容 (提取视频第5分钟的内容)ffmpeg -i video.avi -ss 240 -t 60 clip_5th_minute.mpg]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Future与FutureBuilder实例]]></title>
    <url>%2F2020%2F02%2F12%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Future%E4%B8%8EFutureBuilder%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[flutter练习 - Future与FutureBuilder实例 Future 异步操作 then ：异步操作逻辑 whenComplete ：异步完成时回调 catchError ：捕获异常或异步出错时的回调 timeout ：设置超时时间 Future的then的原型 1Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value),&#123;Function onError&#125;); onValue ：成功的结果回调 onError ：可选 ，执行出现异常 123456789101112131415161718import &apos;dart:async&apos;;Future&lt;String&gt; testFuture() &#123;// throw Error(); return Future.value(&quot;success&quot;);// return Future.error(&quot;error&quot;);&#125;//注意： 如果 catchError 与 onError 同时存在时，则只会调用 onErrorvoid main() &#123; testFuture().then((s) &#123; print(&quot;then : &quot; + s); &#125;, onError: (e) &#123; print(&quot;onError : &quot; + e); &#125;).whenComplete(() &#123; print(&quot;whenComplete&quot;); &#125;).catchError((e) &#123; print(&quot;catchError : &quot; + e); &#125;);&#125; 结合 async， await 123456789101112131415import &apos;dart:async&apos;;test() async &#123; String result = await Future.delayed(Duration(milliseconds: 2000), () &#123; return Future.value(&quot;success&quot;); &#125;); print(&quot;t3 : &quot; + DateTime.now().toString()); print(&quot;result : &quot; + result);&#125;main() &#123; test(); print(&quot;t1 : &quot; + DateTime.now().toString()); print(&quot;t2 : &quot; + DateTime.now().toString());&#125; future.timeout 设置超时时间 12345678910111213import &apos;dart:async&apos;;void main() &#123; Future.delayed(Duration(seconds: 2), () &#123; return &quot;success&quot;; &#125;).timeout(Duration(seconds: 1)).then((s) &#123; print(&quot;then : $s&quot;); &#125;).whenComplete(() &#123; print(&quot;whenComplete&quot;); &#125;).catchError((e) &#123; print(&quot;catchError : $e&quot;); &#125;);&#125; 代码运行会出现如下结果： 12whenCompletecatchError : TimeoutException after 0:00:01.000000: Future not completed FutureBuilder ---- 网络请求，数据库读取 更新 界面 FutureBuildere是一个将异步操作和异步UI更新结合在一起的类，通过它我们可以将网络请求，数据库读取等的结果更新到页面上 FutureBuilder的构造方法 1FutureBuilder(&#123;Key key,Future&lt;T&gt; future,T initialData,@required AsyncWidgetBuilder&lt;T&gt;builder&#125;); future ：Future对象表示此构造器当前连接的异步计算 initialData ：表示一个非空的Future完成前的初始化数据 builder ：AsyncWidgetBuilder类型返回的函数，是一个基于异步交互构建widget的函数 builder: BuildContext context AsyncSnapshot snapshot connectionState 表示与异步计算的连接状态 data - 异步计算接收的最新数据 error - 异步计算接收的最新错误对象； ConnectionState ：与异步计算的连接状态 none ：future还未执行的快照状态 waiting ：连接到一个异步操作，并且等待交互，一般在这种状态的时候，我们可以显示加载框 active ：连接到一个活跃的操作，比如stream流，会不断地返回值，并还没有结束，一般也是可以显示加载框 done：异步操作执行结束，一般在这里可以去拿取异步操作执行的结果，并显示相应的布局 ConnectionState 当前没有连接到任何的异步任务 ConnectionState.none 当前没有连接到任何的异步任务 ConnectionState.waiting 连接到异步任务并等待进行交互 ConnectionState.active 连接到异步任务并开始交互 ConnectionState.done 异步任务中止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import &apos;dart:convert&apos;;import &apos;package:flutter/material.dart&apos;;import &apos;package:http/http.dart&apos; as http;void main() =&gt; runApp(MyApp1());class MyApp1 extends StatefulWidget &#123; @override _MyApp1State createState() =&gt; _MyApp1State();&#125;class _MyApp1State extends State&lt;MyApp1&gt; &#123; String showResult = &apos;&apos;; Future&lt;CommonModel&gt; fetchPost() async &#123; final response = await http .get(&apos;http://www.devio.org/io/flutter_app/json/test_common_model.json&apos;); Utf8Decoder utf8decoder = Utf8Decoder(); //中文乱码// final result=json.decode(response.body); final result = json.decode(utf8decoder.convert(response.bodyBytes)); return CommonModel.fromJson(result); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( appBar: AppBar(title: Text(&apos;FutureBuilder&apos;)), body: FutureBuilder&lt;CommonModel&gt;( future: fetchPost(), builder: (BuildContext context, AsyncSnapshot&lt;CommonModel&gt; snapshot) &#123; switch (snapshot.connectionState) &#123; case ConnectionState.none: return new Text(&apos;Input a URL to start&apos;); case ConnectionState.waiting: return new Center(child: new CircularProgressIndicator()); case ConnectionState.active: return new Text(&apos;&apos;); case ConnectionState.done: if (snapshot.hasError) &#123; return new Text( &apos;$&#123;snapshot.error&#125;&apos;, style: TextStyle(color: Colors.red), ); &#125; else &#123; return new Column(children: &lt;Widget&gt;[ Text(&apos;icon:$&#123;snapshot.data.icon&#125;&apos;), Text(&apos;statusBarColor:$&#123;snapshot.data.statusBarColor&#125;&apos;), Text(&apos;title:$&#123;snapshot.data.title&#125;&apos;), Text(&apos;url:$&#123;snapshot.data.url&#125;&apos;) ]); &#125; &#125; &#125;, ), ), ); &#125;&#125;class CommonModel &#123; final String icon; final String title; final String url; final String statusBarColor; final bool hideAppBar; CommonModel( &#123;this.icon, this.title, this.url, this.statusBarColor, this.hideAppBar&#125;); factory CommonModel.fromJson(Map&lt;String, dynamic&gt; json) &#123; return CommonModel( icon: json[&apos;icon&apos;], title: json[&apos;title&apos;], url: json[&apos;url&apos;], statusBarColor: json[&apos;statusBarColor&apos;], hideAppBar: json[&apos;hideAppBar&apos;], ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Dart流程控制语句]]></title>
    <url>%2F2020%2F01%2F19%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Dart%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[flutter练习 - Dart流程控制语句 if 和 else 12345678void main() &#123; int x =10; if(x%2==0)&#123; print(&quot;$x 能被2整除&quot;); &#125;else&#123; print(&quot;$x 不能被2整除&quot;); &#125;&#125; for（循环） 1234567void main() &#123; var message = new StringBuffer(&quot;Hello Dart&quot;); for (var i = 0; i &lt; 10; i++) &#123; message.write(&quot;!&quot;); &#125; print(message);&#125; 123456void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var i = 0; i &lt; arr.length; i++) &#123; print(i); &#125;&#125; 1234567void main() &#123; var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; numbers.forEach((number) =&gt; print(number)); numbers.forEach((number) &#123; print(number); &#125;);&#125; while 和 do - while (循环) 1234567void main() &#123; var _temp = 0; while (_temp &lt; 5) &#123; print(&quot;这是一个while循环: $&#123;_temp.toString()&#125;&quot;); _temp++; &#125;&#125; 1234567void main() &#123; var _temp = 0; do &#123; print(&quot;这是一个while循环: $&#123;_temp.toString()&#125;&quot;); _temp++; &#125; while (_temp &lt; 5);&#125; break 和 continue 123456789void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var v in arr) &#123; if (v == 4) &#123; break;//跳出循环 &#125; print(v); &#125;&#125; 123456789void main() &#123; var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for (var v in arr) &#123; if (v == 4) &#123; continue;//跳出本次循环 &#125; print(v); &#125;&#125; switch 和 case 1234567891011121314151617void main() &#123; var x = 10; switch (x % 3) &#123; case 0: print(&quot;余数: 0&quot;); break; case 1: print(&quot;余数: 1&quot;); break; case 2: print(&quot;余数: 2&quot;); break; default: print(&quot;其他&quot;); break; &#125;&#125; assert (断言) assert 语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在 Flutter 的调试模式下可以使用 assert。 如果assert条件为 false，则使用 assert 语句中断执行，并抛出一个断言错误异常AssertionError。 如果assert条件为 true，则继续执行下面的语句。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Dart常见运算符]]></title>
    <url>%2F2020%2F01%2F18%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Dart%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[flutter练习 - Dart常见运算符 算数运算符 操作符 含义 + 加 - 减 - expr 一元减号(负号) expr : 表达式的值 * 乘 / 除 ~/ 返回一个整数值的除法 % 取余数,除法剩下的余数 ++var var = var + 1 表达式的值为：var + 1 var++ var = var + 1 表达式的值为：var –var var = var - 1 表达式的值为：var - 1 var– var =var - 1 表达式的值为：var 关系运算符 操作符 含义 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 类型测试操作符 操作符 含义 as 类型转换 is 当对象是相应类型时返回 true is! 当对象不是相应类型时返回 true 赋值操作符 操作符 含义 a = value ; 将 value 赋值给 a b??= value ; 如果 b为空，则将value的值赋值给b，否则，b保持不变 a op b a = a op b a += b a = a + b a -= b a = a - b 逻辑运算符 操作符 含义 !expr 反转以下表达式( 将 false 更改为 true , 反之亦然) || 逻辑或 &amp;&amp; 逻辑与 位运算符 操作符 含义 &amp; 与 | 或 ^ 异或 -expr 一元位补码 ( 0s 变为 1s , 1s 变为 0s ) &lt;&lt; 左移 &gt;&gt; 右移 条件表达式 如果条件为真，返回 expr1,否则返回 expr2 。 condition ? expr1 : expr2 如果 expr1 为非空,则返回其值，否则 计算并返回 expr2 的值 expr1 ?? expr2 级联操作 级联操作符 (…) 可以在同一个对象上连续调用多个函数以及访问成员变量。使用级联操作符可以避免创建临时变量， 并且写出来的代码看起来更加流畅 1234querySelector(&apos;#button&apos;) // Get an object. ..text = &apos;Confirm&apos; // Use its members. ..classes.add(&apos;important&apos;) ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - Kotlin中的【 ?，?.，?:，!! ，filterNotNull 】含义]]></title>
    <url>%2F2020%2F01%2F05%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-KotlinfilterNotNull%20%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[kotlin练习 - Kotlin中的【 ?，?.，?:，!! ，filterNotNull 】含义 ? 可空类型，表示当前是否对象可以为空 12var a:String =&quot;123&quot;a = null //编译报错 12var a:String? =&quot;123&quot;a = null //编译通过 ?. 安全调用操作符 1234var a:String? =&quot;123&quot;a = null //编译通过val length = a.length //编译报错 --- 变量&quot;a&quot;可能会为空val length = a?.length //编译通过 --- 如果 a 非空，就返回 a.length，否则返回 null ?: Elvis 操作符 123var a:String? =&quot;123&quot;a = null //编译通过val lenght = a?.length?:-1 // 当a不为空时，返回a.length，当a为空时，返回-1 !! 操作符，表示当前对象不为空的情况下执行，为空就抛出异常 123var a:String? =&quot;123&quot;a = null //编译通过val lenght = a!!.length //如果a不为空，则返回a.length，如果b为空，则抛出异常 NullPointerException filterNotNull 过滤非空元素 123val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)val intList: List&lt;Int&gt; = nullableList.filterNotNull() println(intList.toString())//[1, 2, 4]]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 常见内联扩展函数学习]]></title>
    <url>%2F2019%2F07%2F21%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%B8%B8%E8%A7%81%E5%86%85%E8%81%94%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 常见内联扩展函数学习 let with apply run repeat also takeIf takeUnless kotlin练习 - 常见内联扩展函数学习 let 定义： fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R 功能： 调用对象（T）的let函数，则该对象为函数的参数。在函数内可以通过 it指代该对象。返回值为函数的最后一行或指定return表达式。 实例： 1234567891011fun main(args: Array&lt;String&gt;) &#123; val data = &quot;孙悟空&quot; data.let &#123; //在函数体内使用it替代object对象去访问其公有的属性和方法 println(it.toString()) &#125; data?.let &#123; // 假如data不为null，代码会执行到此处 println(it.toString()) &#125;&#125; with 定义： fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R 功能： 将对象作为函数的参数，在函数内可以通过this指代该对象。返回值为函数的最后一行或return表达式。 实例： 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; var list = with(mutableListOf&lt;String&gt;()) &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //返回值为函数的最后一行或return表达式 this &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123; var paint = Paint() with(paint) &#123; color = Color.BLACK strokeWidth = 1.0f textSize = 18.0f isAntiAlias = true &#125;&#125; apply 定义： fun T.apply(block: T.() -&gt; Unit): T 功能： 调用对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象。 实例： 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; // apply适用于那些对象初始化需要给其属性赋值的情况。 var list = mutableListOf&lt;String&gt;().apply &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //apply返回的是对象本身 &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123;//apply需要先初始化 var paint = Paint().apply &#123; color = Color.BLACK strokeWidth = 1.0f textSize = 18.0f isAntiAlias = true &#125;&#125; run 定义： fun run(block: () -&gt; R): R fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R 功能： 调用run函数返回值为函数体最后一行，或return表达式。 实例： 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;().run &#123; add(&quot;1&quot;) add(&quot;2&quot;) add(&quot;3&quot;) //run返回的是函数体最后一行，或return表达式 this &#125; println(list.toString())//[1, 2, 3]&#125;fun main(args: Array&lt;String&gt;) &#123; var name = run &#123; &quot;孙悟空&quot; &#125; println(name)//孙悟空&#125; repeat 定义： fun repeat(times: Int, action: (Int) -&gt; Unit) 功能： 重复执行action函数times次，times从0开始 实例： 123456789101112fun main(args: Array&lt;String&gt;) &#123; repeat(3)&#123; //从0开始循环3次 println(&quot;repeat:第$&#123;it&#125;次&quot;) &#125; for(i in 0..2)&#123; println(&quot;for:第$&#123;i&#125;次&quot;) &#125; (0..2).forEach&#123; println(&quot;forEach:第$&#123;it&#125;次&quot;) &#125;&#125; also 定义： fun T.also(block: (T) -&gt; Unit): T 功能： 调用对象的also函数，在函数块内可以通过 it指代该对象,返回值为该对象本身。（注意其和let函数的区别，let返回的是最后一行，also返回的是对象本身） 实例： 12345678fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;().also &#123; it.add(&quot;1&quot;) it.add(&quot;2&quot;) it.add(&quot;3&quot;) &#125; println(list.toString())//[1, 2, 3]&#125; takeIf 定义： fun T.takeIf(predicate: (T) -&gt; Boolean): T? 功能： 传递一个函数参数，如果函数结果为true，返回T对象，否则返回null。 实例： 12345678910fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).takeIf &#123; it.size &gt; 3//满足条件则返回it,否则返回null &#125; if (list != null) &#123; println(list.toString()) &#125; else &#123; println(&quot;list为空&quot;) &#125;&#125; takeUnless 定义： fun T.takeUnless(predicate: (T) -&gt; Boolean): T? 功能： 与takeIf相反，参数函数返回false时返回T对象，否则返回null 实例： 12345678910fun main(args: Array&lt;String&gt;) &#123; var list = mutableListOf&lt;String&gt;(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).takeUnless &#123; it.size &gt; 3//不满足条件则返回it,否则返回null &#125; if (list != null) &#123; println(list.toString()) &#125; else &#123; println(&quot;list为空&quot;) &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus封装]]></title>
    <url>%2F2019%2F07%2F05%2Fandroid%2FEventBus%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[EventBus封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.eventbus.utilsimport com.example.gaokao.event.MessageEventimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.meta.SubscriberInfoIndex/** * * @author: xue * @description EventBus封装 * @date: 2019/7/5 */class EventBusUtil &#123; companion object &#123; /** * 使用索引加速 * 建议在Application中使用 */ fun installIndex(index: SubscriberInfoIndex) &#123; EventBus.builder().addIndex(index).installDefaultEventBus() &#125; /** * 注册 */ fun register(subscribe: Any) &#123; if (!EventBus.getDefault().isRegistered(subscribe)) &#123; EventBus.getDefault().register(subscribe) &#125; &#125; /** * 取消注册 */ fun unregister(subscribe: Any) &#123; EventBus.getDefault().unregister(subscribe) &#125; /** * 发布一个订阅事件 * 必须先注册，才能接收到发布的事件，有点类似于 startActivityForResult（）方法 */ fun postEvent(event: MessageEvent) &#123; EventBus.getDefault().post(event) &#125; /** * 发布粘性事件（可以先发布事件，在注册后在接收） * 粘性事件将最新的信息保存在内存中，取消原始消息，执行最新的消息； * 只有注册后，才能接收消息，如果没有注册，消息将保留在内存中。 */ fun postStickyEvent(event: MessageEvent) &#123; EventBus.getDefault().postSticky(event) &#125; /** * 移除指定的粘性订阅事件 * @param eventType 事件类型 */ fun &lt;T&gt; removeStickyEvent(eventType: Class&lt;T&gt;) &#123; var stickyEvent: T = EventBus.getDefault().getStickyEvent(eventType) if (stickyEvent != null) &#123; EventBus.getDefault().removeStickyEvent(stickyEvent) &#125; &#125; /** * 移除指定的粘性订阅事件 * @param eventType 事件类型 */ fun removeStickyEvent(eventType:Any) &#123; var stickyEvent = EventBus.getDefault().getStickyEvent(eventType as Class&lt;Any&gt;?) if (stickyEvent != null) &#123; EventBus.getDefault().removeStickyEvent(stickyEvent) &#125; &#125; /** * 移除所有的粘性订阅事件 */ fun removeAllStickyEvents()&#123; EventBus.getDefault().removeAllStickyEvents() &#125; /** * 取消事件 * 优先级高的订阅者可以终止事件往下传递 * 只有在事件通过时才能调用（即在事件接收方法中调用） * @param event 事件 */ fun cancelEventDelivery(event:Any)&#123; EventBus.getDefault().cancelEventDelivery(event) &#125; /** * 获取 eventbus 单例 */ fun getEventBus():EventBus&#123; return EventBus.getDefault() &#125; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 协程]]></title>
    <url>%2F2019%2F06%2F30%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 协程 GlobalScope构造函数 launch : 创建协程 async : 创建带返回值的协程，返回 Deferred withContext : 不会创建新的协程，在指定协程上运行代码块 runBlocking : 不是GlobalScope的API，可以单独使用， runBlocking里面的delay()会堵塞当前线程，launch等不会堵塞 12345678910111213141516171819202122fun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch(Dispatchers.Main) &#123; LogUtils.d(&quot;当前线程main: $&#123;Thread.currentThread().name&#125; &quot;) withContextTest() &#125; //newSingleThreadContext 单线程 //newFixedThreadPoolContext 线程池 val singleThreadContext = newSingleThreadContext(&quot;single&quot;) GlobalScope.launch(singleThreadContext) &#123; LogUtils.d(&quot;当前线程_单线程: $&#123;Thread.currentThread().name&#125; &quot;)//single &#125; val fixedThreadPoolContext = newFixedThreadPoolContext(1, &quot;fixed&quot;) GlobalScope.launch(fixedThreadPoolContext) &#123; LogUtils.d(&quot;当前线程_线程池: $&#123;Thread.currentThread().name&#125; &quot;)//fixed &#125;&#125; suspend fun withContextTest() &#123; withContext(Dispatchers.IO) &#123; LogUtils.d(&quot;当前线程io: $&#123;Thread.currentThread().name&#125; &quot;) &#125; &#125; CoroutineContext协程运行的线程调度器 Dispatchers.Default : 默认（如果不写，默认就是Dispatchers.Default模式） Dispatchers.IO : IO线程 Dispatchers.Main : 主线程 Dispatchers.Unconfined : 没指定，就是在当前线程 CoroutineStart 启动模式 CoroutineStart.DEFAULT：默认（如果不写，默认就是CoroutineStart.DEFAULT模式） CoroutineStart.ATOMIC：自动（协程在开始执行之前不能被取消） CoroutineStart.UNDISPATCHED：立即执行协程 CoroutineStart.LAZY：懒加载 Job方法 job.start() : 启动协程，除了 lazy 模式，协程都不需要手动启动 job.join() : 等待协程执行完毕后再执行后面的代码块 job.cancel() : 取消一个协程 协程的取消有些特质，因为协程内部可以在创建协程的，这样的协程组织关系可以称为父协程,子协程： 父协程手动调用 cancel() 或者异常结束，会立即取消它的所有子协程 父协程必须等待所有子协程完成（处于完成或者取消状态）才能完成 子协程抛出未捕获的异常时，默认情况下会取消其父协程 job.cancelAndJoin() : 等待协程取消完毕后再执行后面的代码块 job.isActive : true - 处于活动状态 job.isCancelled : true - 已完成 job.isCompleted : true - 已取消 第一个协程程序 1234567891011121314import kotlinx.coroutines.GlobalScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchfun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch &#123;//在后台启动一个新的协程并继续 delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;我是kotlin&quot;) &#125; println(&quot;你好,&quot;)//协程已在等待时主线程还在继续 Thread.sleep(3000L)// 阻塞主线程 3 秒钟来保证 JVM 存活&#125; println(&quot;运行了吗？&quot;)&#125; 桥接阻塞与非阻塞的世界 12345678910111213141516import kotlinx.coroutines.*fun main(arg: Array&lt;String&gt;) &#123; GlobalScope.launch &#123; //在后台启动新的协程并继续 delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//协程已在等待时主线程还在继续 runBlocking &#123; //主线程 delay(3000L)//延迟 3 秒来保证 JVM 的存活 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;) &#125;&#125; 123456789101112import kotlinx.coroutines.*fun main() = runBlocking&lt;Unit&gt; &#123; //启动主协程 GlobalScope.launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 delay(3000L)// //延迟 3 秒以保持JVM活动 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;)&#125; 等待工作 12345678910111213import kotlinx.coroutines.*fun main() = runBlocking &#123; var job = GlobalScope.launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 job.join()//等到子协程完成后进行 println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗？&quot;)&#125; 结构化的并发 12345678910import kotlinx.coroutines.*fun main() = runBlocking &#123;launch &#123; delay(2000L)//非阻塞的等待 2 秒钟（默认时间单位是毫秒） println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是kotlin&quot;)&#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)//主协同程序在此处继续 &#125; 范围构建器 123456789101112131415161718import kotlinx.coroutines.*fun main() = runBlocking &#123; launch &#123; delay(200L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是Kotlin&quot;) &#125; coroutineScope &#123; launch &#123; delay(500L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你知道吗&quot;) &#125; delay(100L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,运行了吗&quot;) &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)&#125; 提取函数重构 12345678910111213import kotlinx.coroutines.*fun main() = runBlocking &#123; launch &#123; doWorld() &#125; println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,你好,&quot;)&#125;suspend fun doWorld() &#123; delay(2000L) println(&quot;当前线程: $&#123;Thread.currentThread().name&#125; ,我是Kotlin&quot;)&#125; 协同程序重量轻 12345678910import kotlinx.coroutines.*fun main() = runBlocking &#123; repeat(100_000)&#123; launch &#123; delay(1000L) println(&quot;.&quot;) &#125; &#125;&#125; 全局协程像守护线程 123456789101112import kotlinx.coroutines.*fun main() = runBlocking &#123; GlobalScope.launch &#123; repeat(1000) &#123; println(&quot;当前是第$&#123;(it + 1)&#125;个线程&quot;) delay(500L) &#125; &#125; delay(1300L)&#125; 协程请求网络数据 123456789101112131415161718class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) coroutine.setOnClickListener &#123; click() &#125; &#125; private fun click() = runBlocking &#123; GlobalScope.launch(Dispatchers.Main) &#123; coroutine.text = GlobalScope.async(Dispatchers.IO) &#123; // 比如进行了网络请求 // 放回了请求后的结构 return@async &quot;main&quot; &#125;.await() &#125; &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础-RxJava2学习]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid%2FRxJava2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文参考RxJava2 只看这一篇文章就够了，强烈推荐大家去看一下。 RxJava的组成 被观察者-------Observable 观察者-----------Observer 订阅---------------subscribe 1234567891011121314151617181920212223242526272829303132333435//被观察者 Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;a&quot;); emitter.onNext(&quot;b&quot;); emitter.onNext(&quot;c&quot;); emitter.onComplete(); &#125; &#125;); //观察者 Observer observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(s); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;; //订阅 observable.subscribe(observer); 创建操作符 create() 12345678//创建一个被观察者 Observable&lt;String&gt;observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(&quot;Hello Java&quot;); emitter.onComplete(); &#125; &#125;); just() --------发送事件不可以超过10个 123456Observable.just(1,2,3,4,5,6,7,8,9,0).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(integer); &#125; &#125;); From 操作符 fromArray() ----- 可以发送数组(数量可以大于10个) 1234567Integer integers[] = &#123;0,1,2,3,4,5&#125;; Observable.fromArray(integers).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(integer); &#125; &#125;); fromCallable() -----被观察者返回一个结果值给观察者 1234567891011Observable.fromCallable(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;hello&quot;; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); fromIterable() ---------可以发送一个List集合给观察者 123456789101112List&lt;String&gt;list = new ArrayList&lt;&gt;(); list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); list.add(&quot;5&quot;); Observable.fromIterable(list).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); fromFuture() ------- 可以发送一个Future 123456789101112131415161718FutureTask&lt;String&gt;futureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;Hello&quot;; &#125; &#125;); //doOnSubscribe()----- 开始订阅时才会执行 Observable.fromFuture(futureTask).doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; futureTask.run();//开始执行 &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); defer() -------------- 只有观察者订阅时，才会创建新的被观察者 1234567891011121314151617181920212223242526272829303132333435String str_name = &quot;张三&quot;; public void rxjava() &#123; Observable&lt;String&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends String&gt; call() throws Exception &#123; return Observable.just(str_name); &#125; &#125;); str_name = &quot;李四&quot;; Observer observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(&quot;str_name = &quot; + s);//王五，赵六 &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;; str_name = &quot;王五&quot;; observable.subscribe(observer); str_name = &quot;赵六&quot;; observable.subscribe(observer); &#125; timer() -------------当到了指定时间就发送一个0L的值给观察者 123456Observable.timer(2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;along : &quot;+aLong);//along : 0 &#125; &#125;); interval() ------------ 每隔一段时间就会发送一个事件（从0开始不断增加1的数字） 12345678910111213141516Observable.interval(2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 0， along : 1 &#125; &#125;); //延迟5s后开始执行 Observable.interval(5,2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 0， along : 1 &#125; &#125;); intervalRange() ------------ 可以指定发送事件的开始值，数量，其他的和interval()一样 1234567891011121314151617181920212223242526272829//start：起始数值 -------- 10//count：发射数量 -------- 3//initialDelay：延迟执行时间-------- 5s//period：发射周期时间------2s//unit：时间单位//数字从10开始，传递3次，第一次执行延迟5s，每隔2s执行一次Observable.intervalRange(10,3,5,2, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 10， along : 11， along : 12 &#125;&#125;);//start：起始数值 -------- 10//count：发射数量 -------- 3//initialDelay：延迟执行时间-------- 5s//period：发射周期时间------2s//unit：时间单位//Scheduler：线程调度//数字从10开始，传递3次，第一次执行延迟5s，每隔2s执行一次，在新线程中执行Observable.intervalRange(10,3,5,2, TimeUnit.SECONDS, Schedulers.newThread()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;当前线程 ：&quot;+Thread.currentThread().getName());//RxNewThreadScheduler //每隔2s 执行一次 along : 从0开始每次回增加1 LogUtils.e(&quot;along : &quot;+aLong);//along : 10， along : 11， along : 12 &#125;&#125;); range() ----------- 发送一定范围内的事件 1234567//从10开始，执行3次 Observable.range(10,3).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;integer : &quot;+integer);//10,11,12 &#125; &#125;); rangeLong() ----和range()方法类似，只是数据类型为Long 1234567//从10开始，执行3次 Observable.rangeLong(10,3).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.e(&quot;along : &quot;+aLong);//10,11,12 &#125; &#125;); empty() &amp; never() &amp; error() empty() --------------- 直接发送 onComplete() 事件 12345678910111213141516171819//只会进入 onSubscribe(),onComplete()方法 Observable.empty().subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); never() ---------------- 不发生任何时间 12345678910111213141516171819//只会进入 onSubscribe()方法 Observable.never().subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); error() -------------------发送onError()事件 12345678910111213141516171819//只会进入 onSubscribe(),onError()方法 Observable.error(new NullPointerException()).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.e(&quot;==================onSubscribe&quot;); &#125; @Override public void onNext(Object o) &#123; LogUtils.e(&quot;==================onNext&quot;); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;==================onError &quot; + e); &#125; @Override public void onComplete() &#123; LogUtils.e(&quot;==================onComplete&quot;); &#125; &#125;); 转换操作符 map() -------------- 将被观察者发送的数据类型转换成其他的类型 1234567891011Observable.just(1,2,3,4,5).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return &quot;当前值为：&quot;+integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s); &#125; &#125;); flatMap() ----------------- 作用于map() 方法类似，返回一个 新的Observerable (无序： flatMap()可能交错的发送事件,最终结果的顺序可能并是不原始Observable发送时的顺序 ) 1234567891011121314151617Observable.just(1, 2, 3, 4, 5).flatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;当前值为：&quot;+integer); if (integer == 3) &#123; return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);//延迟10毫秒 &#125; else &#123; return Observable.fromIterable(list); &#125; &#125; &#125;).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; LogUtils.e(o.toString());//当前值为：1,2,4,5,3 ------无序的 &#125; &#125;); concatMap() ------------ 作用和flatMap() 方法一样（有序：concatMap()转发事件的顺序是有序的） 1234567891011121314151617Observable.just(1, 2, 3, 4, 5).concatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;当前值为：&quot;+integer); if (integer == 3) &#123; return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);//延迟10毫秒 &#125; else &#123; return Observable.fromIterable(list); &#125; &#125; &#125;).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; LogUtils.e(o.toString());//当前值为：1,2,3,4,5, ------有序的 &#125; &#125;); buffer() ------------- 从需要发送的事件中获取一定数量的事件，将这些事件存放到缓冲区中一并发出 123456789101112131415//count: 缓冲区元素的数量//skip: 就代表缓冲区满了之后，发送下一次事件的时候要跳过的元素数量Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(List&lt;Integer&gt; integers) throws Exception &#123; LogUtils.e(&quot;缓冲区大小: &quot; + integers.size()); String str = &quot;&quot;; for (int i = 0; i &lt; integers.size(); i++) &#123; str = str + &quot;,&quot; + integers.get(i); &#125; LogUtils.e(&quot;当前元素: &quot; + str); &#125; &#125;); groupBy() ---------------- 将发送的数据进行分组，每个分组都会返回一个被观察者 12345678910111213141516171819Observable.just(1, 2, 3, 4, 5, 6, 7) .groupBy(new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer) throws Exception &#123; return integer % 2;//分为2组 &#125; &#125;) .subscribe(new Consumer&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void accept(GroupedObservable&lt;Integer, Integer&gt; integerIntegerGroupedObservable) throws Exception &#123; LogUtils.e(&quot; 第&quot; + integerIntegerGroupedObservable.getKey()+&quot;组&quot;); integerIntegerGroupedObservable.subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;第&quot; + integerIntegerGroupedObservable.getKey() + &quot;组，当前元素: &quot; + integer); &#125; &#125;); &#125; &#125;); scan() ---------------- 将数据按照一定的逻辑合并数据 1234567891011121314Observable.just(1, 2, 3, 4, 5, 6, 7) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer1, Integer integer2) throws Exception &#123; LogUtils.e(&quot;integer1 = &quot;+integer1);//上一次的结果 LogUtils.e(&quot;integer2 = &quot;+integer2); return integer1 +integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;integer1 + integer2 =&quot;+integer); &#125; &#125;); window() --------------将发送数据 按指定数量进行分组 12345678910111213Observable.just(1, 2, 3, 4, 5, 6, 7) .window(3) .subscribe(new Consumer&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void accept(Observable&lt;Integer&gt; integerObservable) throws Exception &#123; integerObservable.subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前元素: &quot; + integer); &#125; &#125;); &#125; &#125;); 组合操作符 zip() -------------- 将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。 12345678910111213141516171819202122232425262728Observable.zip( Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;), Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;), new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s, String s2) throws Exception &#123; String res = s + s2; LogUtils.d(&quot;A &amp; B 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.d( &quot;onNext: &quot; + s); &#125;&#125;); concat() -------------- 将多个观察者组合在一起，然后按照之前的发送顺序发送事件，最多只能合并4个被观察者 1234567891011Observable.concat( Observable.just(1,2), Observable.just(3,4), Observable.just(5,6), Observable.just(7,8) ).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前数字：&quot;+integer);//1,2,3,4,5,6,7,8 &#125; &#125;); concatArray() ------------ 作用和concat()方法一样，可以发送多于4个的被观察者 12345678910111213Observable.concatArray( Observable.just(1,2), Observable.just(3,4), Observable.just(5,6), Observable.just(7,8), Observable.just(9,10), Observable.just(11,12) ).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.e(&quot;当前数字：&quot;+integer);//1,2,3,4,5,6,7,8,9,10,11,12 &#125; &#125;); merge() -------------- 作用和concat() 方法一样，只不过concat()是串行发送，而merge() 是并行发送事件 123456789101112131415161718192021Observable.merge( Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long,String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;A&quot;+aLong; &#125; &#125;), Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long,String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;B&quot;+aLong; &#125; &#125;) ).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.e(s);//A，B 交替出现---------- A0,B0,A1,B1,A2,B2 &#125; &#125;); combineLatest() ------------ 作用和zip()类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送。 12345678910111213141516171819202122232425262728Observable.combineLatest( Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;), Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;), new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s, String s2) throws Exception &#123; String res = s + s2; LogUtils.d(&quot;A &amp; B 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtils.d( &quot;onNext: &quot; + s); &#125;&#125;); concatArrayDelayError() &amp; mergeArrayDelayError()&amp; combineLatestDelayError() -------------- 如果有一个被观察者发送了一个Error事件，那么就结束发送，如果你想将Error() 事件延迟到所有被观察者都发送完事件后再执行。 1234567891011121314151617181920212223242526272829303132Observable.concatArrayDelayError( Observable.just(1,2), Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(3); e.onError(new NullPointerException()); e.onNext(4); &#125; &#125;), Observable.just(5,6) ).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.e(&quot;onNext : 当前数字：&quot;+integer);//1,2,3,5,6 &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError : &quot;+e.toString());//java.lang.NullPointerException &#125; @Override public void onComplete() &#123; &#125; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940Observable.mergeArrayDelayError( Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;A&quot; + aLong; &#125; &#125;), Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;C1&quot;); e.onNext(&quot;C2&quot;); e.onNext(&quot;C3&quot;); e.onError(new NullPointerException()); e.onNext(&quot;C4&quot;); e.onNext(&quot;C5&quot;); &#125; &#125;), Observable.interval(1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; return &quot;B&quot; + aLong; &#125; &#125;) ).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.e(s); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Observable&lt;String&gt; observable1 = Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s1 = &quot;A&quot; + aLong; LogUtils.d(&quot;A 发送的事件: &quot; + s1); return s1; &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS).map(new Function&lt;Long, String&gt;() &#123; @Override public String apply(Long aLong) throws Exception &#123; String s2 = &quot;B&quot; + aLong; LogUtils.d(&quot;B 发送的事件: &quot; + s2); return s2; &#125; &#125;); Observable&lt;String&gt; observable3 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;C1&quot;); e.onNext(&quot;C2&quot;); e.onNext(&quot;C3&quot;); e.onError(new NullPointerException()); e.onNext(&quot;C4&quot;); e.onNext(&quot;C5&quot;); &#125; &#125;); Observable.combineLatestDelayError(new ObservableSource[]&#123;observable1, observable2, observable3&#125;, new Function() &#123; @Override public Object apply(Object o) throws Exception &#123; Object[] objects = (Object[]) o; String res = &quot;&quot;; for (int i = 0; i &lt; objects.length; i++) &#123; res = res + String.valueOf(objects[i]); &#125; LogUtils.d(&quot;A &amp; B &amp; C 发送的事件: &quot; + res); return res; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; LogUtils.d(s); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(e.toString()); &#125; @Override public void onComplete() &#123; &#125; &#125;); reduce() ------------ 将所有数据聚合在一起才会发送事件给观察者 12345678910111213141516Observable.just(1,2,3,4,5,6,7,8) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(Integer integer, Integer integer2) throws Exception &#123; int res = integer + integer2; LogUtils.d(&quot;integer : &quot; + integer); LogUtils.d(&quot;integer2 : &quot; + integer2); LogUtils.d(&quot;res : &quot; + res); return res; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;accept : &quot;+ integer); &#125; &#125;); collect() ------------ 将数据收集到数据结构当中。 1234567891011121314151617Observable.just(1,2,3,4,5,6,7,8) .collect(new Callable&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public ArrayList&lt;Integer&gt; call() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125; &#125;, new BiConsumer&lt;ArrayList&lt;Integer&gt;, Integer&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers, Integer integer) throws Exception &#123; integers.add(integer); &#125; &#125;).subscribe(new Consumer&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public void accept(ArrayList&lt;Integer&gt; integers) throws Exception &#123; LogUtils.d(integers); &#125; &#125;); startWith() &amp; startWithArray() ------------ 在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出 12345678910Observable.just(6, 7, 8) .startWithArray(3, 4, 5) .startWith(2) .startWithArray(0, 1) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(String.valueOf(integer)); &#125; &#125;); count() ------------ 返回被观察者发送事件的数量 12345678Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .count() .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; LogUtils.d(&quot;发送数量：&quot; + aLong);//8 &#125; &#125;); 功能操作符 delay() -------------- 延迟一段事件发送事件 12345678910111213141516171819202122Observable.just(1, 2, 3, 4) .delay(2, TimeUnit.SECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnEach() ---------------- Observable 每发送一个之前都会先回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() &#123; @Override public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception &#123; LogUtils.d(&quot;doOnEach 方法 &quot;+ integerNotification.getValue()); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnNext() ----------------- Observable 每发送 onNext() 之前都会先回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnNext(new Consumer&lt;Integer&gt;()&#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;doOnNext 方法 &quot;+ integer); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doAfterNext() -------------- Observable 每发送 onNext() 之后都会回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doAfterNext(new Consumer&lt;Integer&gt;()&#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;doAfterNext 方法 &quot;+ integer); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnComplete ------------------ Observable 每发送 onComplete() 之前都会回调这个方法 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnComplete 方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnError() ---------------- Observable 每发送 onError() 之前都会回调这个方法 12345678910111213141516171819202122232425262728293031323334353637Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .doOnError(new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;doOnError() :&quot;+throwable.toString()); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnSubscribe() ----------------- Observable 每发送 onSubscribe() 之前都会回调这个方法 12345678910111213141516171819202122232425262728293031323334353637Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125;&#125;) .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; LogUtils.d(&quot;doOnSubscribe()方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnDispose() -------------- 当调用 Disposable 的取消订阅dispose()方法之后回调该方法 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if(integer==2)&#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnLifecycle() ------------- 在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnLifecycle(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; LogUtils.d(&quot;doOnLifecycle accept&quot;); //disposable.dispose();//取消订阅 &#125; &#125;, new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnLifecycle Action &quot;); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if (integer == 2) &#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doOnTerminate() &amp; doAfterTerminate() --------------- doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。如果取消订阅之后 doAfterTerminate() 就不会被回调 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doOnTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnTerminate() 方法&quot;); &#125; &#125;) .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doAfterTerminate() 方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); doFinally() ------------- 在所有事件发送完毕之后回调该方法，doFinally() 在取消订阅后也都会被回调，且都会在事件序列的最后。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125; &#125;) .doFinally(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doFinally() 方法&quot;); &#125; &#125;) .doAfterTerminate(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doAfterTerminate() 方法&quot;); &#125; &#125;) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; LogUtils.d(&quot;doOnDispose（）方法&quot;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); this.disposable = d; &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); if (integer == 2) &#123; disposable.dispose();//取消订阅 &#125; &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onErrorReturn() ------------------- 当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .onErrorReturn(new Function&lt;Throwable, Integer&gt;() &#123; @Override public Integer apply(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;onErrorReturn() 方法&quot;+throwable.toString()); return 404; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onErrorResumeNext() ----------- 当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125; &#125;) .onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception &#123; LogUtils.e(&quot;onErrorResumeNext()方法&quot;+throwable.toString()); return Observable.just(5,6,7,8,9); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); onExceptionResumeNext() -------------- 与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception 12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new Exception(&quot;111&quot;)); &#125; &#125;) .onExceptionResumeNext(new Observable&lt;Integer&gt;() &#123; @Override protected void subscribeActual(Observer&lt;? super Integer&gt; observer) &#123; observer.onNext(404); observer.onNext(405); observer.onComplete(); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retry() ----------------- 如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数 123456789101112131415161718192021222324252627282930313233Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onError(new NullPointerException()); &#125;&#125;) .retry(2) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retryUntil() --------------- 出现错误事件之后，可以通过此方法判断是否继续发送事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445final int[] i = &#123;0&#125;; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); e.onError(new NullPointerException()); &#125; &#125;) .retryUntil(new BooleanSupplier() &#123; @Override public boolean getAsBoolean() throws Exception &#123; if (i[0] &gt;= 6) &#123;//停止继续发送 return true; &#125; else &#123; return false; &#125; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; i[0] += integer; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); retryWhen() ---------------- 当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onNext(5); e.onError(new NullPointerException()); &#125; &#125;) .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123; return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Throwable throwable) throws Exception &#123; if (throwable instanceof NullPointerException)&#123; return Observable.error(new Throwable(&quot;终止啦&quot;)); &#125;else&#123; return Observable.just(6,7,8,9); &#125; &#125; &#125;); &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); repeat() -------------- 重复发送被观察者的事件，times 为发送次数 12345678910111213141516171819202122232425262728293031323334Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .repeat(2) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); repeatWhen() ------------------ 这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件 1234567891011121314151617181920212223242526272829303132333435363738394041Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123; return Observable.empty();//直接发送 onComplete() 事件// return Observable.just(1);//不发送任何事件// return Observable.error(new Exception(&quot;404&quot;));//发送 onError() 事件 &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.e(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); subscribeOn() ------------ 指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效 123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtils.d(&quot;当前线程：&quot;+Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.newThread()) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); LogUtils.d(&quot;onSubscribe()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); LogUtils.d(&quot;onNext()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); LogUtils.d(&quot;onError()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); LogUtils.d(&quot;onComplete()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; &#125;); observeOn() ----------------- 指定观察者的线程，每指定一次就会生效一次 12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtils.d(&quot;当前线程：&quot;+Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4);// e.onError(new NullPointerException()); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); LogUtils.d(&quot;onSubscribe()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); LogUtils.d(&quot;onNext()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); LogUtils.d(&quot;onError()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); LogUtils.d(&quot;onComplete()方法—当前线程：&quot;+Thread.currentThread().getName()); &#125; &#125;); 过滤操作符 filter() -------------- 通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送 123456789101112131415161718192021222324252627282930313233Observable.just(1, 2, 3, 4, 5, 6) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; if (integer % 2 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); ofType() ----------------- 可以过滤不符合该类型事件 123456789101112131415161718192021222324Observable.just(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,1,2,3) .ofType(Integer.class) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); skip() &amp; skipLast() --------------- 跳过正序某些事件，count 代表跳过事件的数量 12345678910111213141516171819202122232425Observable.just(1,2,3,4,5,6) .skip(2)//跳过前面2个事件 .skipLast(2)//跳过后面2个事件 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); distinct() ------------ 过滤事件序列中的重复事件 123456789101112131415161718192021222324Observable.just(1,2,3,4,4,3,2,1) .distinct() .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer);//1,2,3,4 &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); distinctUntilChanged() ---------------- 过滤掉连续重复的事件 123456789101112131415161718192021222324Observable.just(1,2,3,4,4,3,2,1) .distinctUntilChanged() .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer);//1，2，3，4，3，2，1 &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); take() &amp; takeLast() --------------------- 控制观察者接收的事件的数量 12345678910111213141516171819202122232425Observable.just(1,2,3,4,5,6,7,8,9) .take(3)//只接收前面3个// .takeLast(2)//只接收后面2个 .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); debounce() ----------------- 如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者 12345678910111213141516171819202122232425262728293031Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); Thread.sleep(900); e.onNext(2); &#125; &#125;) .debounce(1,TimeUnit.SECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Integer integer) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + integer); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); firstElement() &amp;&amp; lastElement() ----------------- firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素 12345678910111213141516Observable.just(1, 2, 3, 4) .firstElement() .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;firstElement() 方法 &quot; + integer); &#125; &#125;); Observable.just(1, 2, 3, 4) .lastElement() .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;lastElement() 方法 &quot; + integer); &#125; &#125;); elementAt() &amp; elementAtOrError() -------------- elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 123456789101112131415161718Observable.just(1, 2, 3, 4) .elementAt(4) .subscribe(new Consumer &lt; Integer &gt; () &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;elementAt() 方法 &quot; + integer); &#125; &#125;); Observable.just(1, 2, 3, 4) .elementAtOrError(4)//报错 .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;elementAtOrError() 方法 &quot; + integer); &#125; &#125;); 条件操作符 all() ---------------- 判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false 123456789101112Observable.just(1, 2, 3, 4) .all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 5; &#125; &#125;).subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); takeWhile() ------------- 可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .takeWhile(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 4;//如果第一条数据没有满足条件，后面的都不会进行 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;); skipWhile() ---------- 可以设置条件，当某个数据满足条件时不发送该数据，反之则发送 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .skipWhile(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &lt; 4;//当满足条件时，后面的都运行 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125;&#125;); takeUntil() -------------- 可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了 123456789101112Observable.just(1, 2, 3, 4, 3, 2) .takeUntil(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer &gt;= 3;//当满足条件后，从下一次的事件开始都不会发送了 &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;); skipUntil() ------------ 当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者 123456789101112131415161718192021222324Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS) .skipUntil(Observable.intervalRange(1, 3, 2, 1, TimeUnit.SECONDS)) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Long along) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + along); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); sequenceEqual() --------------- 判断两个 Observable 发送的事件是否相同 1234567Observable.sequenceEqual(Observable.just(1, 2, 3), Observable.just(1, 2, 3)) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); contains() ------------- 判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false 12345678Observable.just(1,2,3,4,5) .contains(3) .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); isEmpty() --------------- 判断事件序列是否为空 ( true ：空 ) 12345678910111213Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onComplete(); &#125; &#125;) .isEmpty() .subscribe(new Consumer&lt;Boolean&gt;() &#123; @Override public void accept(Boolean aBoolean) throws Exception &#123; LogUtils.d(&quot;aBoolean : &quot; + aBoolean); &#125; &#125;); amb() --------------- amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃 123456789101112131415161718192021222324252627List&lt;Observable&lt;Long&gt;&gt; list = new ArrayList&lt;&gt;();list.add(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS));list.add(Observable.intervalRange(11, 5, 0, 1, TimeUnit.SECONDS));list.add(Observable.intervalRange(21, 5, 2, 1, TimeUnit.SECONDS));Observable.amb(list) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtils.d(&quot;onSubscribe()方法&quot;); &#125; @Override public void onNext(Long along) &#123; LogUtils.d(&quot;onNext()方法 : &quot; + along); &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(&quot;onError()方法 :&quot; + e.toString()); &#125; @Override public void onComplete() &#123; LogUtils.d(&quot;onComplete()方法&quot;); &#125; &#125;); defaultIfEmpty() -------------- 如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值 12345678910111213Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onComplete(); &#125; &#125;) .defaultIfEmpty(1001) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtils.d(&quot;integer : &quot; + integer); &#125; &#125;);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>rxjava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 集合练习]]></title>
    <url>%2F2019%2F03%2F14%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 集合练习 Set集合 Set集合创建 12345678910111213141516171819202122232425fun main(args: Array&lt;String&gt;) &#123; //创建不可变集合，返回Set var set = setOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(set)//[java, kotlin, go] println(&quot;setOf 返回类型 $&#123;set.javaClass&#125;&quot;) //创建可变集合，返回值MutableSet var mutablemap = mutableListOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) mutablemap[0] = &quot;JavaScript&quot; println(mutablemap)//[JavaScript, kotlin, go] println(&quot;mutableListOf 返回类型 $&#123;mutablemap.javaClass&#125;&quot;) //创建LinkedHashSet集合 var linkedHashSet = linkedSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(linkedHashSet) println(&quot;linkedHashSet 返回类型 $&#123;linkedHashSet.javaClass&#125;&quot;) //创建HashSet集合 var hashSet = hashSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(hashSet)//不保证元素的顺序--[kotlin, go, java] //创建TreeSet集合 var treeSet = sortedSetOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) println(treeSet)//集合按从小到大排列--[go, java, kotlin]&#125; Set集合的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//创建不可变集合，返回Set var set = setOf(&quot;java&quot;, &quot;kotlin&quot;, &quot;go&quot;) //判断是否所有的元素长度都大于5 ------所有元素都满足条件 println(set.all &#123; it.length &gt; 5 &#125;)// false //判断是否任意一元素的长度大于5 ------任意元素都满足条件 println(set.any &#123; it.length &gt; 5 &#125;)//true //以Lambda 表达式的值为key , 集合元素为value ,组成的Map集合 var map = set.associateBy(&#123; &quot;我正在学习$&#123;it&#125;&quot; &#125;) println(map)//&#123;我正在学习java=java, 我正在学习kotlin=kotlin, 我正在学习go=go&#125; //使用in、!in运算符 println(&quot;java&quot; in set)// true println(&quot;java&quot; !in set)// false //删除Set集合前面两个元素 var dropedList = set.drop(2) println(dropedList)// [go] //对Set集合进行过滤: 需要得到所有包含 va 的集合, var filteredList1 = set.filter(&#123; &quot;va&quot; in it &#125;)//如果没有返回空元素的集合 println(filteredList1)//[java] //查找Set集合中包含 va 的元素，如果找到就返回该元素，否则返回 null var filteredList2 = set.find(&#123; &quot;o&quot; in it &#125;) println(filteredList2)//kotlin var filteredList3 = set.find(&#123; &quot;va1&quot; in it &#125;) println(filteredList3)//null //将Set集合中所有字符串拼接在一起 var foldedList1 = set.fold(&quot;&quot;, &#123; acc, s -&gt; acc + s &#125;) println(foldedList1)//javakotlingo var foldedList2 = set.fold(&quot;456&quot;, &#123; acc, s -&gt; acc +&quot; 123 $&#123;s&#125;&quot; &#125;) println(foldedList2)//456 123 java 123 kotlin 123 go //查找某个元素的出现位置------没有就会返回-1 println(set.indexOf(&quot;kotlin&quot;))// 1 println(set.indexOf(&quot;kotlin1&quot;))// -1 //循环遍历 var books = setOf(&quot;疯狂java讲义&quot;, &quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;, &quot;疯狂android讲义&quot;) for (book in books)&#123; println(book) &#125; books.forEach(&#123; println(it) &#125;) for (i in books.indices)&#123; println(books.elementAt(i)) &#125; var books = mutableSetOf(&quot;疯狂java讲义&quot;) //新增 books.addAll(setOf(&quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;)) books.add(&quot;疯狂android讲义&quot;) println(books.toString())//[疯狂java讲义, 疯狂kotlin讲义, 疯狂IOS讲义, 疯狂android讲义] //删除 books.remove(&quot;疯狂kotlin讲义&quot;) println(books.toString())//[疯狂java讲义,疯狂IOS讲义, 疯狂android讲义] books.removeAll(setOf(&quot;疯狂java讲义&quot;)) println(books.toString())//[疯狂IOS讲义, 疯狂android讲义] //清空所有 books.clear() println(books.toString())//[] //只保留公共的元素 books = mutableSetOf(&quot;疯狂java讲义&quot;, &quot;疯狂kotlin讲义&quot;, &quot;疯狂IOS讲义&quot;, &quot;疯狂android讲义&quot;) books.retainAll(setOf(&quot;疯狂kotlin讲义&quot;, &quot;疯狂PHP讲义&quot;, &quot;疯狂android讲义&quot;)) println(books.toString())//[疯狂kotlin讲义, 疯狂android讲义] List集合 List集合创建 1234567891011121314var list1 = listOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list1.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] var list2 = listOfNotNull(1, 2, 3, 4, 5, null, 7, 8, 9) println(list2.toString())//[1, 2, 3, 4, 5, 7, 8, 9] var list3 = mutableListOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list3.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] list3.add(10) list3.set(5, 6) println(list3.toString())//[1, 2, 3, 4, 5, 6, 7, 8, 9,10] var list4 = arrayListOf(1, 2, 3, 4, 5, null, 7, 8, 9) println(list4.toString())//[1, 2, 3, 4, 5, null, 7, 8, 9] list4.set(5, 6) list4.add(10) println(list4.toString())//[1, 2, 3, 4, 5, 6, 7, 8, 9,10] List集合的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //遍历List var list1 = listOf(&quot;Java&quot;, null, &quot;Kotlin&quot;, &quot;Go&quot;) list1.forEach &#123; println(it) &#125; for (str in list1) &#123; println(str) &#125; for (i in list1.indices) &#123; println(list1[i]) println(&quot;get = $&#123;list1.get(i)&#125;&quot;) println(&quot;elementAt = $&#123;list1.elementAt(i)&#125;&quot;) &#125; var index = list1.indexOf(&quot;Go&quot;) println(&quot;Go 在数组中的位置：$&#123;index&#125;&quot;)//3 var list2 = mutableListOf(1, 2, 3, 1, 8, 3, 4, 6, 1, 4, 2, 3) //最后一次出现的的位置 var last1 = list2.lastIndexOf(2)//10 //最后一次出现的的位置 var last2 = list2.indexOfLast &#123; it == 2 &#125;//10 //第一次出现的位置 var first = list2.indexOfFirst &#123; it == 2 &#125;//1 println(&quot;2在数组中第一次出现在$&#123;first&#125;,最后一次出现在$&#123;last1&#125;,$&#123;last2&#125;&quot;) //返回集合 var list3 = listOf(&quot;Java&quot;, null, &quot;Kotlin&quot;, &quot;PHP&quot;, null, &quot;Go&quot;) var sublist = list3.subList(2, 5)//从第2个到第5个之间的元素 println(sublist.toString())//[Kotlin, PHP, null]// var list4 = mutableListOf(&quot;Java&quot;, &quot;JavaScript&quot;, null, &quot;HTML&quot;, &quot;Kotlin&quot;, null, &quot;Python&quot;, &quot;PHP&quot;, &quot;Go&quot;) var list4 = mutableListOf(&quot;Java&quot;, null, &quot;HTML&quot;, &quot;Go&quot;) println(list4)//[Java, null, HTML, Go] //新增 list4.add(&quot;Python&quot;) list4.add(2, &quot;C++&quot;) list4.addAll(listOf(&quot;Kotlin&quot;, null)) println(list4)//[Java, null, C++, HTML, Go, Python, Kotlin, null] //删除 list4.removeAt(1) println(list4)//[Java, C++, HTML, Go, Python, Kotlin, null] //list4[6] =&quot;CSS&quot;; list4.set(6, &quot;CSS&quot;) println(list4)//[Java, C++, HTML, Go, Python, Kotlin, CSS] list4.remove(&quot;Go&quot;) println(list4)//[Java, C++, HTML, Python, Kotlin, CSS] list4.add(3, &quot;Go&quot;) list4.add(5, &quot;Go&quot;) println(list4)//[Java, C++, HTML, Go, Python, Go, Kotlin, CSS] //替换元素 list4.replaceAll &#123; if (it.equals(&quot;Go&quot;)) &#123; &quot;go&quot; &#125; else &#123; it &#125; &#125; println(list4)//[Java, C++, HTML, go, Python, go, Kotlin, CSS] //删除 list4.removeAll(listOf(&quot;go&quot;)) println(list4)//[Java, C++, HTML, Python, Kotlin, CSS] //清空 list4.clear() println(list4)//[] Map集合 Map集合创建 12345678910111213141516171819//不可变map集合var map1 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map1)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//可变集合MutableMapvar map2 = mutableMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map2)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;map2.put(&quot;Python&quot;, 5)println(map2)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=5&#125;map2.remove(&quot;JavaScript&quot;)println(map2)//&#123;Java=1, HTML=3, Kotlin=4, Python=5&#125;//HashMap集合----不保证key-value的顺序var map3 = hashMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map3)//&#123;Java=1, HTML=3, JavaScript=2, Kotlin=4&#125;//LinkedHashMap集合---key-value按添加顺序排列var map4 = linkedMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)println(map4)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//SortedMap集合------ key-value按key由小到大排列var map5 = sortedMapOf(&quot;Java&quot; to 1, &quot;Python&quot; to 5, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;JavaScript&quot; to 2, &quot;Go&quot; to 6)println(map5)//&#123;Go=6, HTML=3, Java=1, JavaScript=2, Kotlin=4, Python=5&#125; Map集合的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var map1 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)//当map集合中所有key-value对都满足条件返回truevar all = map1.all &#123; it.key.length &gt;= 4 &amp;&amp; it.value &gt; 0&#125;println(all)//true//当map集合中任意一个key-value对满足条件就会返回truevar any = map1.any &#123; it.key.length &gt;= 10 &amp;&amp; it.value &gt; 1&#125;println(any)//true//判断map集合中是否有对于key的key-valueprintln(&quot;Java&quot; in map1);//trueprintln(&quot;Java&quot; !in map1);//falseprintln(&quot;Go&quot; in map1);//falseprintln(&quot;Go&quot; !in map1);//true//对map进行过滤，要求key中包含：Javavar filterMap1 = map1.filter &#123; &quot;Java&quot; in it.key &#125;println(filterMap1)//&#123;Java=1, JavaScript=2&#125;var filterMap2 = map1.filter &#123; it.key in &quot;Java&quot; &#125;println(filterMap2)//&#123;Java=1&#125;//通过map集合，返回一个新的Listvar mappedList1 = map1.map &#123; &quot;《疯狂$&#123;it.key&#125;》讲义,第$&#123;it.value&#125;个&quot; &#125;var mappedList2 = map1.map &#123; &quot;《疯狂$&#123;it.key&#125;》讲义&quot; to &quot;第$&#123;it.value&#125;个&quot; &#125;println(mappedList1)//[《疯狂Java》讲义,第1个, 《疯狂JavaScript》讲义,第2个, 《疯狂HTML》讲义,第3个, 《疯狂Kotlin》讲义,第4个]println(mappedList2)//[(《疯狂Java》讲义, 第1个), (《疯狂JavaScript》讲义, 第2个), (《疯狂HTML》讲义, 第3个), (《疯狂Kotlin》讲义, 第4个)]//Map集合中key-value对中 value最大的值var maxby1 = map1.maxBy &#123; it.value &#125;println(maxby1)//Kotlin=4//Map集合中key-value对中 value最小的值var minby1 = map1.minBy &#123; it.value &#125;println(minby1)//Java=1//Map集合中key-value对中 key的长度最大的值var maxby2 = map1.maxBy &#123; it.key.length &#125;println(maxby2)//JavaScript=2//Map集合中key-value对中 key的长度最小的值var minby2 = map1.minBy &#123; it.key.length &#125;println(minby2)//Java=1var map2 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)var map3 = mapOf(&quot;Python&quot; to 1, &quot;Go&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4)//集合相加---相当于并集println(map2 + map3)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=1, Go=2&#125;//集合相减---减去公共的元素println(map2 - map3)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;var plus = map2.plus(map3)println(plus)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Python=1, Go=2&#125;var minus = map2.minus(map3)println(minus)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4&#125;//遍历Map集合var map4 = mapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;Go&quot; to 5)for (en in map4.entries) &#123; println(&quot;$&#123;en.key&#125; -&gt; $&#123;en.value&#125;&quot;)&#125;for (key in map4.keys) &#123; println(&quot;$&#123;key&#125; -&gt; $&#123;map4[key]&#125;&quot;)&#125;for ((key, value) in map4) &#123; println(&quot;$&#123;key&#125; -&gt; $&#123;value&#125;&quot;)&#125;map4.forEach(&#123; println(&quot;$&#123;it.key&#125; -&gt; $&#123;it.value&#125;&quot;)&#125;)var map5 = mutableMapOf(&quot;Java&quot; to 1, &quot;JavaScript&quot; to 2, &quot;HTML&quot; to 3, &quot;Kotlin&quot; to 4, &quot;Go&quot; to 5)map5[&quot;Go&quot;] = 0println(map5)//&#123;Java=1, JavaScript=2, HTML=3, Kotlin=4, Go=0&#125;map5.put(&quot;HTML&quot;, 10)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4, Go=0&#125;map5.remove(&quot;Go&quot;)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4&#125;map5.remove(&quot;Java&quot;, 2)println(map5)//&#123;Java=1, JavaScript=2, HTML=10, Kotlin=4&#125;map5.remove(&quot;Java&quot;, 1)println(map5)//&#123;JavaScript=2, HTML=10, Kotlin=4&#125;map5.putAll(hashMapOf(&quot;PHP&quot; to 6, &quot;C++&quot; to 7,&quot;JavaScript&quot; to 8 ))println(map5)//&#123;JavaScript=8, HTML=10, Kotlin=4, PHP=6, C++=7&#125;//清空Map集合map5.clear()println(map5)//&#123;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView 图片选择]]></title>
    <url>%2F2019%2F01%2F20%2Fandroid%2FWebView%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[WebView 图片选择 最近需要做webview选择图片，就找了一些资料，记录一下。 本文参考:Android使用WebView从相册/拍照中添加图片 自定义WebChromeClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344import android.net.Uri;import android.webkit.ValueCallback;import android.webkit.WebChromeClient;import android.webkit.WebView;/** * WebView 上传文件 */public class ReWebChomeClient extends WebChromeClient &#123; private OpenFileChooserCallBack mOpenFileChooserCallBack; public ReWebChomeClient(OpenFileChooserCallBack openFileChooserCallBack) &#123; mOpenFileChooserCallBack = openFileChooserCallBack; &#125; //For Android 3.0+ public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; mOpenFileChooserCallBack.openFileChooserCallBack(uploadMsg, acceptType); &#125; // For Android &lt; 3.0 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openFileChooser(uploadMsg, &quot;&quot;); &#125; // For Android &gt; 4.1.1 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openFileChooser(uploadMsg, acceptType); &#125; // For Android 5.0+ @Override public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) &#123; mOpenFileChooserCallBack.showFileChooserCallBack(filePathCallback); return true; &#125; public interface OpenFileChooserCallBack &#123; void openFileChooserCallBack(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType); void showFileChooserCallBack(ValueCallback&lt;Uri[]&gt; filePathCallback); &#125;&#125; 使用ReWebChomeClient 1234567891011121314151617181920212223242526272829//定义变量private ValueCallback&lt;Uri&gt; uploadMessage;private ValueCallback&lt;Uri[]&gt; uploadMessageAboveL;//用来判断是否需要给WebView返回nullprivate int web_image = 0;private String picFilePath;//图片保存路径private int IDENTITY_IMAGE_REQUEST_CODE_Album = 1;//相册private int IDENTITY_IMAGE_REQUEST_CODE_Photograph = 2;// 拍照private int FILE_CHOOSER_RESULT_CODE = 3;//图片选择...//设置WebChromeClientmWebView.setWebChromeClient(mWebChromeClient);...private ReWebChomeClient mWebChromeClient = new ReWebChomeClient(new ReWebChomeClient.OpenFileChooserCallBack() &#123; @Override public void openFileChooserCallBack(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123;//Android &gt;=3.0 uploadMessage = uploadMsg; openImageChooserActivity(); &#125; @Override public void showFileChooserCallBack(ValueCallback&lt;Uri[]&gt; filePathCallback) &#123;// Android &gt;= 5.0 uploadMessageAboveL = filePathCallback; openImageChooserActivity(); &#125; &#125;); 选择图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 private void openImageChooserActivity() &#123; web_image = 0;//判断是否已经选择了 //自定义选择图片提示框 AlertDialog dialog = new AlertDialog.Builder(mContext).setItems(R.array.head_type_array, (dialog1, which) -&gt; &#123; //如果点击了dialog的选项，修改变量，不要在setOnDismissListener()方法中 web_image = 1; selected(which); &#125;).create(); dialog.show(); dialog.setOnDismissListener(dialog12 -&gt; &#123; if (web_image == 0) &#123; getImageWebView(null); &#125; &#125;); &#125; public void selected(int position) &#123; switch (position) &#123; case 0://相册 getPermissionsStorage(); break; case 1:// 拍照 getPermissionsCamera(); break; case 2://选择图片 Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); i.setType(&quot;image/*&quot;); startActivityForResult(Intent.createChooser(i, &quot;Image Chooser&quot;), FILE_CHOOSER_RESULT_CODE); break; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == IDENTITY_IMAGE_REQUEST_CODE_Photograph) &#123;//拍照 if (resultCode == Activity.RESULT_OK) &#123; // 添加图片 if (picFilePath == null) &#123; picFilePath = Datas.picPathSD + BitmapUtil.pictime; &#125; getImageWebView(picFilePath); &#125; else &#123; // 删除图片 BitmapUtil.deleteTempFile(picFilePath); getImageWebView(null); &#125; &#125; else if (requestCode == IDENTITY_IMAGE_REQUEST_CODE_Album) &#123;//相册 if (resultCode == 1020) &#123; String str_images = StringUtils.null2Length0(data.getStringExtra(&quot;images&quot;)); getImageWebView(str_images); &#125; else &#123; getImageWebView(null); &#125; &#125; else if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;//选择图片 if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) &#123; return; &#125; Uri result = data == null || resultCode != RESULT_OK ? null : data.getData(); if (uploadMessageAboveL != null) &#123; onActivityResultAboveL(requestCode, resultCode, data); &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(result); &#125; &#125; &#125; private void getImageWebView(String str_image) &#123;//将图片路径返回给webview if (!StringUtils.isEmpty(str_image)) &#123; Uri uri = getImageContentUri(mContext, new File(str_image)); if (uploadMessageAboveL != null) &#123; Uri[] uris = new Uri[]&#123;uri&#125;; uploadMessageAboveL.onReceiveValue(uris); uploadMessageAboveL = null; &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(uri); uploadMessage = null; &#125; &#125; else &#123; if (uploadMessageAboveL != null) &#123; uploadMessageAboveL.onReceiveValue(null); uploadMessageAboveL = null; &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(null); uploadMessage = null; &#125; &#125; &#125;//选择图片 @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123; if (uploadMessageAboveL == null) &#123; return; &#125; Uri[] results = null; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; String dataString = intent.getDataString(); LogUtils.e(&quot;web&quot;, dataString); ClipData clipData = intent.getClipData(); if (clipData != null) &#123; results = new Uri[clipData.getItemCount()]; for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123; ClipData.Item item = clipData.getItemAt(i); results[i] = item.getUri(); &#125; &#125; if (dataString != null) &#123; results = new Uri[]&#123;Uri.parse(dataString)&#125;; &#125; &#125; &#125; uploadMessageAboveL.onReceiveValue(results); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); uploadMessage = null; uploadMessageAboveL = null; &#125;//将文件File转成Uri public Uri getImageContentUri(Context context, File imageFile) &#123; String filePath = imageFile.getAbsolutePath(); Cursor cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new String[]&#123;MediaStore.Images.Media._ID&#125;, MediaStore.Images.Media.DATA + &quot;=? &quot;, new String[]&#123;filePath&#125;, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; int id = cursor.getInt(cursor.getColumnIndex(MediaStore.MediaColumns._ID)); Uri baseUri = Uri.parse(&quot;content://media/external/images/media&quot;); return Uri.withAppendedPath(baseUri, &quot;&quot; + id); &#125; else &#123; if (imageFile.exists()) &#123; ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DATA, filePath); return context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); &#125; else &#123; return null; &#125; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - Container控件]]></title>
    <url>%2F2018%2F12%2F29%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-Container%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flutter练习 - Container控件 属性 key： Container唯一标识符，用于查找更新。 alignment： 控制child的对齐方式，如果container或者container父节点尺寸大于child的尺寸，这个属性设置会起作用，有很多种对齐方式。 padding： decoration内部的空白区域，如果有child的话，child位于padding内部。padding与margin的不同之处在于，padding是包含在content内，而margin则是外部边界，设置点击事件的话，padding区域会响应，而margin区域不会响应。 color： 用来设置container背景色，如果foregroundDecoration设置的话，可能会遮盖color效果。 decoration： 绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。 foregroundDecoration： 绘制在child前面的装饰。 width： container的宽度，设置为double.infinity可以强制在宽度上撑满，不设置，则根据 child和父节点两者一起布局。 height： container的高度，设置为double.infinity可以强制在高度上撑满。 constraints： 添加到child上额外的约束条件。 margin： 围绕在decoration和child之外的空白区域，不属于内容区域。 transform： 设置container的变换矩阵，类型为Matrix4。 child： container中的内容widget。 实例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp(new myApp());&#125;class myApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;text&quot;, home: Scaffold( appBar: AppBar( title: Text(&quot;Container练习&quot;), ), body: Container( constraints: new BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, ), decoration: new BoxDecoration( //边框 border: new Border.all(width: 2.0, color: Colors.red), //背景色 color: Colors.grey, //边框圆角 borderRadius: new BorderRadius.all(new Radius.circular(20.0)), image: new DecorationImage( image: new NetworkImage( &quot;http://www.zhangjiaxue.cn/images/avatar.jpg&quot;), centerSlice: new Rect.fromLTRB(270.0, 180.0, 1360.0, 730.0), ), ), padding: const EdgeInsets.all(8.0), alignment: Alignment.center, child: new Text( &apos;Hello World&apos;, style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.blue), ), //变换矩阵 transform: new Matrix4.rotationZ(0.3), ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter练习 - flutter基本控件]]></title>
    <url>%2F2018%2F12%2F26%2Fflutter%2Fflutter%E7%BB%83%E4%B9%A0%20-%20flutter%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Flutter 基本控件 Widget StatelessWidget — 只能用来展示信息，不能有用户交互 StatefulWidget — 可以通过改变状态使得 UI 发生变化 文本 Text 123456class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Text(&quot;text&quot;); &#125;&#125; 图片 Image 资源：Image.asset(name); 文件：Image.file(file); 内存：Image.memory(bytes); 网络：Image.network(src); 12345678910class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Image.network( &quot;http://www.zhangjiaxue.cn/images/avatar.jpg&quot;, width: 150.0, height: 150.0, ); &#125;&#125; 按钮（ FlatButton ，RaisedButton ） FlatButton RaisedButton 12345678910111213141516class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var flatBtn = FlatButton( //按钮被点击的时候得到回调 onPressed: () =&gt; print(&apos;FlatButton pressed&apos;), //设置按钮的内容 child: Text(&apos;FlatButton BUTTON&apos;), ); var raisedButton = RaisedButton( onPressed: () =&gt; print(&apos;RaisedButton pressed&apos;), child: Text(&apos;RaisedButton BUTTON&apos;), ); return raisedButton; &#125;&#125; 文本输入框 TextField 123456789class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text(&quot;输入&quot;)), body: TextField(), ); &#125;&#125; 显示弹框 dialog 1234567891011121314151617181920212223242526class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( child: Text(&quot;点击按钮弹出Dialog&quot;), onPressed: () &#123; showDialog( // 第一个 context 是参数名，第二个 context 是 State 的成员变量 context: context, builder: (_) &#123; return AlertDialog( // dialog 的内容 content: Text(&quot;提示框&quot;), // actions 设置 dialog 的按钮 actions: &lt;Widget&gt;[ FlatButton( child: Text(&apos;OK&apos;), // 用户点击按钮后，关闭弹框 onPressed: () =&gt; Navigator.pop(context), ) ], ); &#125;); &#125;); &#125;&#125; 布局 Container（容器） 12345678910111213141516171819202122class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( padding: EdgeInsets.all(8.0), margin: EdgeInsets.all(4.0), width: 200.0, height: 200.0, decoration: BoxDecoration( // 背景色 color: Colors.grey, // 圆角 borderRadius: BorderRadius.circular(5.0), ), // 把文本放在 Container 的中间 child: Center( child: Text(&apos;text&apos;), ), ); &#125;&#125; Row(水平布局) 12345678910111213141516class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //水平布局 return Row( // 只有一个子元素的 widget，一般使用 child 参数来设置；Row 可以包含多个子控件， // 对应的则是 children。 children: &lt;Widget&gt;[ Text(&apos;text1&apos;), Text(&apos;text2&apos;), Text(&apos;text3&apos;), Text(&apos;text4&apos;), ], ); &#125;&#125; Column(竖直布局) 1234567891011121314class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //垂直布局 return Column( children: &lt;Widget&gt;[ Text(&apos;text1&apos;), Text(&apos;text2&apos;), Text(&apos;text3&apos;), Text(&apos;text4&apos;), ], ); &#125;&#125; Stack(层叠布局) 123456789101112131415161718class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Stack( // Aligment 的取值范围为 [-1, 1]，Stack 中心为 (0, 0)， // 这里设置为 (-0.5, -0.5) 后，可以让文本对齐到 Container 的 1/4 处 alignment: const Alignment(-0.5, -0.5), children: &lt;Widget&gt;[ Container( width: 200, height: 200, color: Colors.blue, ), Text(&quot;text2&quot;), ], ); &#125;&#125; 布局控件 Flexible Flexible组件可以使Row、Column、Flex等子组件在主轴方向有填充可用空间的能力(例如，Row在水平方向，Column在垂直方向)，但是它与Expanded组件不同，它不强制子组件填充可用空间。 123456789101112131415161718192021222324252627282930313233343536class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&apos;水平方向布局&apos;), ), body: new Row(children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&apos;点击红色按钮事件&apos;); &#125;, color: Colors.red, child: new Text(&apos;红色按钮&apos;), ), new Flexible( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&apos;点击黄色按钮事件&apos;); &#125;, color: Colors.yellow, child: new Text(&apos;黄色按钮&apos;), ), ), new RaisedButton( onPressed: () &#123; print(&apos;点击蓝色按钮事件&apos;); &#125;, color: Colors.blue, child: new Text(&apos;蓝色按钮&apos;), ), ]), ); &#125;&#125; Expanded Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。 123456789101112131415161718192021222324252627282930313233343536class TestWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&apos;水平方向布局&apos;), ), body: new Row(children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123; print(&apos;点击红色按钮事件&apos;); &#125;, color: Colors.red, child: new Text(&apos;红色按钮&apos;), ), new Expanded( flex: 1, child: new RaisedButton( onPressed: () &#123; print(&apos;点击黄色按钮事件&apos;); &#125;, color: Colors.yellow, child: new Text(&apos;黄色按钮&apos;), ), ), new RaisedButton( onPressed: () &#123; print(&apos;点击蓝色按钮事件&apos;); &#125;, color: Colors.blue, child: new Text(&apos;蓝色按钮&apos;), ), ]), ); &#125;&#125; 非常感谢 Flutter学习指南：UI布局和控件（微信号：玉刚说 YugangTalk），作者：水晶虾饺 flutter控件Flexible和 Expanded的区别 ，作者：chunchun1230]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 数组练习]]></title>
    <url>%2F2018%2F12%2F17%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 数组练习 数组创建 使用arrayOf()函数：这种方式无需显示指定数组的长度，但需要依次列出每个数组元素。 1234567fun main(args: Array&lt;String&gt;) &#123; //创建包含指定元素的数组 var arg1 = arrayOf(&quot;Java&quot;,&quot;Kotlin&quot;,&quot;PHP&quot;,&quot;Swift&quot;) var arg2 = arrayOf(0,1,2,3,4,5) println(&quot;arg1 = $&#123;Arrays.toString(arg1)&#125;&quot;) println(&quot;arg2 = $&#123;Arrays.toString(arg2)&#125;&quot;)&#125; 使用arrayOfNulls()函数：这种方法需要显示指定数组的长度，数组元素全部被初始化为null。 1234fun main(args: Array&lt;String&gt;) &#123; //创建指定长度，元素为null的数组 var arg3 = arrayOfNulls&lt;Int&gt;(5)&#125; 使用emptyArray()函数：这种方法会创建一个长度为0的空数组。 12345fun main(args: Array&lt;String&gt;) &#123; //创建长度为0的空数组 var arg4 = emptyArray&lt;String&gt;() var arg5 = emptyArray&lt;Int&gt;()&#125; 使用Array(size : Int,init ：(Int) -&gt; T )构造器：这种方法需要显示指定数组的长度，并可通过Lambda表达式来动态计算各数组元素的值， 1234567fun main(args: Array&lt;String&gt;) &#123; //创建指定长度，使用Lambda表达式初始化数组元素的数组 var arg6 = Array(5,&#123;(it * 2+97).toChar()&#125;) var arg7 = Array(6,&#123;&quot;fkit&quot;&#125;) println(&quot;arg6 = $&#123;Arrays.toString(arg6)&#125;&quot;) println(&quot;arg7 = $&#123;Arrays.toString(arg7)&#125;&quot;)&#125; 其他 Array：Kotlin专门提供了 ByteArray、ShortArray、IntArra、LongArray、CharArray、FloatArray、DoubleArray、BooleanArray 分别对应java中的 byte[]、short[]、int[]、long[]、char[]、floar[]、double[]、boolean[] 这8种基本数据类型的数组。 1234567891011fun main(args: Array&lt;String&gt;) &#123; var intArr = intArrayOf(2,3,4,5,6) var doubleArr = doubleArrayOf(2.1,2.2,2.3,2.4) var intArr2 = IntArray(5,&#123;it*it&#125;) var charArr = CharArray(5,&#123;(it*2+97).toChar()&#125;) println(&quot;intArr = $&#123;Arrays.toString(intArr)&#125;&quot;) println(&quot;doubleArr = $&#123;Arrays.toString(doubleArr)&#125;&quot;) println(&quot;intArr2 = $&#123;Arrays.toString(intArr2)&#125;&quot;) println(&quot;charArr = $&#123;Arrays.toString(charArr)&#125;&quot;)&#125; 数组使用 get(index) 方法 ，set(index，value)方法 12345678fun main(args: Array&lt;String&gt;) &#123; var strArray = arrayListOf&lt;String&gt;(&quot;Java&quot;,&quot;Kotlin&quot;,&quot;Go&quot;,&quot;Swift&quot;) println(strArray[1])//Kotlin println(strArray.get(1))//Kotlin strArray.set(0,&quot;Python&quot;) strArray[2] = &quot;Groovy&quot; println(strArray.toString())//[Python, Kotlin, Groovy, Swift]&#125; 数组遍历 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; var books = arrayListOf&lt;String&gt;(&quot;疯狂java讲义&quot;, &quot;疯狂android讲义&quot;, &quot;疯狂kotlin讲义&quot;) for (book in books) &#123; println(book) &#125; for (i in 0 until books.size) &#123; println(books[i]) &#125; //根据数组的索引来遍历数组 for (i in books.indices)&#123;//索引 = size -1 println(books[i]) &#125; for ((index,value) in books.withIndex())&#123;//索引 = size -1 println(&quot;索引为$&#123;index&#125;的元素为：$&#123;value&#125;&quot;) &#125;&#125; 数组常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153var indexs = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) //所有元素都要满足条件则返回 true var isAll = indexs.all &#123; x -&gt; x &gt; 0 &amp;&amp; x &lt; 10 &#125; print(isAll)//true //任一数组元素满足条件则返回 true var isAny = indexs.any &#123; x -&gt; x == 9 &#125; println(isAny)//true //将数组转为List集合 var indexList = indexs.asList() println(indexList.toString()) //返回Map集合 var indexMap1 = indexs.associate &#123; x -&gt; x to x * x &#125; println(indexMap1.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; var indexMap2 = indexs.associate &#123; it to it * it &#125; println(indexMap2.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //返回Map集合 var indexMap3 = indexs.associateBy &#123; it * it &#125;//Map&lt;K,T&gt;中的K println(indexMap3.toString())//&#123;1=1, 4=2, 9=3, 16=4, 25=5, 36=6, 49=7, 64=8, 81=9&#125; var indexMap4 = indexs.associateBy(&#123; it &#125;, &#123; it * it &#125;) println(indexMap4.toString())//&#123;1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; var indexMap5 = indexs.associateBy(&#123; it * it &#125;)//Map&lt;K,T&gt;中的K println(indexMap5.toString())//&#123;1=1, 4=2, 9=3, 16=4, 25=5, 36=6, 49=7, 64=8, 81=9&#125; //在将数组转成的Map集合插入map，最后返回修改后的map var map6 = mutableMapOf(10 to 100, 11 to 121, 12 to 144) var indexMap6 = indexs.associateByTo(map6, &#123; it &#125;, &#123; it * it &#125;) println(map6.toString())//&#123;10=100, 11=121, 12=144, 1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //在将数组转成的Map集合插入map，最后返回修改后的map var map7 = mutableMapOf(10 to 100, 11 to 121, 12 to 144) var indexMap7 = indexs.associateTo(map7, &#123; it to it * it &#125;) println(map7.toString())//&#123;10=100, 11=121, 12=144, 1=1, 2=4, 3=9, 4=16, 5=25, 6=36, 7=49, 8=64, 9=81&#125; //数组平均值 var average = indexs.average(); println(&quot;平均值为$average&quot;)//5.0 //通过二分法查询element出现的索引，如果找不到则返回负数-------要求数组中的元素已经按升序排序 var binarySearch1 = indexs.binarySearch(4, 0, 3) println(&quot;4在数组(数组从第一个元素,到第三个元素)中的位置：$binarySearch1&quot;)//-4 var binarySearch2 = indexs.binarySearch(4) println(&quot;4在数组中的位置：$binarySearch2&quot;)//3 //判断数组中是否包含元素 var contains = indexs.contains(10); println(&quot;数组中是否有元素10：$&#123;contains&#125;&quot;)//false var indexs1 = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9) //判断两个数组是否相等 var contentDeepEquals = indexs.contentDeepEquals(indexs1) println(&quot;两个数组是否相等：$&#123;contentDeepEquals&#125;&quot;)//true //将数组转成String var str_index = indexs.contentToString(); println(str_index)//[1, 2, 3, 4, 5, 6, 7, 8, 9] //复制数组成为一个新数组 var copyof1 = indexs.copyOf() println(&quot;copyof1 = $&#123;copyof1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9] indexs[0] = 0; println(&quot;copyof1 = $&#123;copyof1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9] indexs[0] = 1; var copyof2 = indexs.copyOf(5) println(&quot;copyof2 = $&#123;copyof2.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5] var copyof3 = indexs.copyOf(10) println(&quot;copyof3 = $&#123;copyof3.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] //复制数组（通过索引指定） var copyOfRange1 = indexs.copyOfRange(0, 10) println(&quot;copyOfRange1 = $&#123;copyOfRange1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] indexs[0] = 10 println(&quot;copyOfRange1 = $&#123;copyOfRange1.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5, 6, 7, 8, 9, null] indexs[0] = 1 var copyOfRange2 = indexs.copyOfRange(0, 5) println(&quot;copyOfRange2 = $&#123;copyOfRange2.contentToString()&#125;&quot;)//[1, 2, 3, 4, 5] //数组满足条件的数量 var count1 = indexs.count(&#123; it &gt; 5 &#125;) println(&quot;数组中大于5的元素有：$&#123;count1&#125;个&quot;)//4 var indexs2 = arrayOf(1, 2, 3, 1, 4, 2, 3, 4, 1) //去掉数组中重复的元素 var indexs2_distinct1 = indexs2.distinct() println(indexs2_distinct1.toString())//[1, 2, 3, 4] var indexs2_distinct2 = indexs2.distinctBy &#123; it % 2 == 0 &#125; println(indexs2_distinct2.toString())//[1, 2] //去掉数组中前3个元素 var drop = indexs.drop(3); println(drop.toString()) //去掉前面满足条件的元素，当出现第一个条件不满足时，返回后面的所有元素 var dropWhile = indexs.dropWhile &#123; it &lt;= 3 &#125; println(dropWhile.toString())//[4, 5, 6, 7, 8, 9] //去掉数组中后3个元素 var dropLast = indexs.dropLast(3); println(dropLast.toString())//[1, 2, 3, 4, 5, 6] //去掉前面满足条件的元素，当出现第一个条件不满足时，返回前面的所有元素 var dropLastWhile = indexs.dropLastWhile &#123; it &gt; 6 &#125; println(dropLastWhile.toString())//[1, 2, 3, 4, 5, 6] //将数组中的元素赋值为element var indexs4 = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) indexs4.fill(3) println(indexs4.contentToString())//[3, 3, 3, 3, 3, 3, 3, 3, 3] var indexs5 = arrayOf&lt;Int&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9) indexs5.fill(3, 0, 5); println(indexs5.contentToString())//[3, 3, 3, 3, 3, 6, 7, 8, 9] var first1 = indexs.first() println(&quot;数组的第一个元素：$&#123;first1&#125;&quot;)//1 var first2 = indexs.first &#123; it &gt; 5 &#125; println(&quot;数组的第一个满足条件的元素：$&#123;first2&#125;&quot;)//6 var last1 = indexs.last() println(&quot;数组的最后一个元素：$&#123;last1&#125;&quot;)//9 var last2 = indexs.last &#123; it &gt; 5 &#125; println(&quot;数组的最后一个满足条件的元素：$&#123;last2&#125;&quot;)//9 //求和 var fold = indexs.fold(0, &#123; acc, i -&gt; acc + i &#125;) println(&quot;数组元素和为：$&#123;fold&#125;&quot;) //搜索元素查询的位置 var index1 = indexs.indexOf(5)//从前往后 var index2 = indexs.lastIndexOf(5)//从后往前 println(&quot;元素5在数组中的位置是：$&#123;index1&#125;和$&#123;index2&#125;&quot;) var indexs6 = arrayOf(1, 2, 3, 1, 4, 2, 3, 4, 1) var index3 = indexs6.indexOfFirst &#123; it == 3 &#125;//第一次出现的位置 var index4 = indexs6.indexOfLast &#123; it == 3 &#125;//最后一次查询的位置 println(&quot;元素3在数组中第一次出现在$&#123;index3&#125;,最后一次出现在$&#123;index4&#125;&quot;)//2,6 var indexs7 = arrayListOf&lt;Int&gt;(3, 4, 5, 6, 7, 8, 9) var indexs8 = arrayListOf&lt;Int&gt;(1, 2, 5, 6) //intersect(交集)，subtract(差集)，union(并集)，minus(补集) var intersect = indexs7.intersect(indexs8) var subtract = indexs7.subtract(indexs8) var union = indexs7.union(indexs8) var minus = indexs7.minus(indexs8) println(&quot;交集：$&#123;intersect&#125;&quot;)//[5, 6] println(&quot;差集：$&#123;subtract&#125;&quot;)//[3, 4, 7, 8, 9] println(&quot;并集：$&#123;union&#125;&quot;)//[3, 4, 5, 6, 7, 8, 9, 1, 2] println(&quot;补集：$&#123;minus&#125;&quot;)//[3, 4, 7, 8, 9] //数组最大值 var max = indexs.max();//9 //数组最小值 var min = indexs.min();//1 println(&quot;数组中的最大值：$&#123;max&#125; 最小值：$&#123;min&#125;&quot;) var indexs9 = arrayListOf&lt;Int&gt;(1, 9, 3, 7, 2, 5, 4, 6, 8) //排序 indexs9.sort(); println(indexs9)//[1, 2, 3, 4, 5, 6, 7, 8, 9] //排序 val mapList = mutableListOf(1 to &quot;A&quot; , 2 to &quot;B&quot;, 5 to &quot;C&quot;, 3 to &quot;D&quot;) mapList.sortBy &#123; it.first &#125; println(mapList) // [(1, A), (2, B), (3, D), (5, C)] mapList.sortBy &#123; it.second &#125; println(mapList) // [(1, A), (2, B), (5, C), (3, D)]]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - 循环练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - 循环练习 for-in 循环 for-in 循环语法格式 for（常量名 in 字符串|范围|集合）{} 123456//循环打印1-10fun main (args : Array&lt;String&gt;)&#123;for(num in 1..10)&#123; println(&quot;num = $num&quot;)&#125;&#125; while 循环 while循环语法格式 [init_statements] while (test_expression){ body_statements [iteration_statements] } while每次在执行循环体之前，都要先对test_expression 循环条件求值，如果循环条件为真，则运行循环体。从上面的语法格式来看，迭代语句 iteration_statements 总是位于循环体的最后，因此只有当循环体能成功执行完成时，while循环才会执行迭代语句iteration_statements；如果test_expression 循环条件为假，则循环体部分将不会执行。 1234567891011//循环 0-10fun main (args : Array&lt;String&gt;)&#123; var num =0 println(&quot;循环开始&quot;) while (num&lt;10)&#123; println(&quot;num = $num&quot;) //迭代语句 num++ &#125; println(&quot;循环结束&quot;)&#125; do while 循环 do while循环语法格式 [init_statements] do{ body_statements [iteration_statements] } while (test_expression){ } do while 循环 先执行循环体，再判断循环条件，如果条件为真，则执行下一次循环，否则中止循环 123456789fun main (args : Array&lt;String&gt;)&#123; var num =0 println(&quot;循环开始&quot;) do&#123; println(&quot;num = $num&quot;) num++ &#125;while (num&lt;10) println(&quot;循环结束&quot;)&#125; 嵌套循环 使用 for-in 和 while 嵌套循环 12345678910fun main (args : Array&lt;String&gt;)&#123; println(&quot;循环开始&quot;) for(i in 0 until 10)&#123;//0-9 var j = 0 while (j&lt;3)&#123; println(&quot;i = $i +，j = $&#123;j++&#125;&quot;) &#125; &#125; println(&quot;循环结束&quot;)&#125; 控制循环 使用break结束循环 12345678910fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) for (i in 0..10) &#123;//0-10 println(&quot;i = $i&quot;) if (i==3)&#123; break//结束循环 &#125; &#125; println(&quot;循环结束&quot;)&#125; 使用标识符@ 12345678910111213141516171819fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) outer@ for (i in 0..10) &#123;//0-10 for (j in 0 until 3)&#123;//0-2 println(&quot;i = $i ,j = $j&quot;) if(j==1)&#123; //跳出outer标签所标识的循环 break@outer &#125; &#125; &#125; println(&quot;循环结束&quot;)&#125;运行结果： 循环开始 i = 0 ,j = 0 i = 0 ,j = 1 循环结束 ** 代码解释： ​ 程序从外层循环进入内层循环后，当j等于1时，程序执行break@outer语句，这条语句将会结束outer@标签指定的循环。（并不是结束break所在的内层循环，而是结束 outer@标签所标识的外层循环） ** 注意： ​ 通常警跟break之后的标签，必须在break所在的循环的外层循环之前定义才有意义 使用continue忽略本次循环剩下的语句 使用continue结束本次循环 12345678910fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) for (i in 0..10) &#123;//0-10 if (i == 2) &#123; continue//结束本次循环 &#125; println(&quot;i = $i&quot;) &#125; println(&quot;循环结束&quot;)&#125; 使用标识符@ 12345678910111213141516171819202122fun main(args: Array&lt;String&gt;) &#123; //外层循环 outer@ for (i in 0..3) &#123;//0-3 // 内层循环 for (j in 0 until 3)&#123;//0-2 println(&quot;i = $i ,j = $j&quot;) if(j==1)&#123; //忽略outer标签所标识的循环中当次循环剩下的语句 continue@outer &#125; &#125; &#125; &#125;循环结果： i = 0 ,j = 0 i = 0 ,j = 1 i = 1 ,j = 0 i = 1 ,j = 1 i = 2 ,j = 0 i = 2 ,j = 1 i = 3 ,j = 0 i = 3 ,j = 1 代码解释 程序从外层循环进入内层循环后，当j等于1时，程序执行continue@outer语句，这条语句将会结束outer@标签指定的循环的当次循环，直接开始下一次循环，内层循环没有机会执行完成。 使用return结束方法 使用return语句结束函数或方法 123456789101112131415fun main(args: Array&lt;String&gt;) &#123; println(&quot;循环开始&quot;) text() println(&quot;循环结束&quot;)&#125;fun text()&#123;//循环到3后，结束循环for(i in 0 until 10)&#123;//0-9println(&quot;i = $i&quot;) if(i==3)&#123; return &#125; //当i等于3时，无法执行 println(&quot;循环中...&quot;)&#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - when分支结构练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-when%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - when分支练习 when表达式 12345when(expression)&#123;expression1 -&gt; statements...expression2 -&gt; statements...else -&gt; statements...&#125; 例子1 12345678910fun main(args: Array&lt;String&gt;) &#123; var score = &apos;B&apos; when (score) &#123; &apos;A&apos; -&gt; println(&quot;优秀&quot;) &apos;B&apos; -&gt; println(&quot;良好&quot;) &apos;C&apos; -&gt; println(&quot;中&quot;) &apos;D&apos; -&gt; println(&quot;及格&quot;) else -&gt; println(&quot;不及格&quot;) &#125;&#125; 例子2 123456789101112fun main(args: Array&lt;String&gt;) &#123; var score = &apos;c&apos; when (score) &#123; &apos;A&apos;, &apos;a&apos; -&gt; println(&quot;优秀&quot;) &apos;B&apos;, &apos;b&apos; -&gt; println(&quot;良好&quot;) &apos;C&apos;, &apos;c&apos; -&gt; println(&quot;中&quot;) &apos;D&apos;, &apos;d&apos; -&gt; println(&quot;及格&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子3 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = &apos;A&apos; var str = &quot;EFGH&quot; when (score) &#123; str[0]-4,str[1]-4 -&gt; println(&quot;优秀&quot;) str[2]-4,str[3]-4 -&gt; println(&quot;中&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子4 123456789fun main(args: Array&lt;String&gt;) &#123; var date = Date() when (date) &#123; Date() -&gt; println(&quot;优秀&quot;) else -&gt; &#123; println(&quot;不及格&quot;) &#125; &#125;&#125; 例子5 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = &apos;B&apos; var str = when (score) &#123; &apos;A&apos; -&gt; &quot;优秀&quot; &apos;B&apos; -&gt; &quot;良好&quot; &apos;C&apos; -&gt; &quot;中&quot; &apos;D&apos; -&gt; &quot;及格&quot; else -&gt; &quot;不格&quot; &#125; println(str)&#125; 例子6 1234567891011fun main(args: Array&lt;String&gt;) &#123; var score = Random().nextInt(100) var str = when (score) &#123; in 90..100 -&gt; &quot;优秀&quot; in 80..90 -&gt; &quot;良好&quot; in 70..80 -&gt; &quot;中&quot; in 60..70 -&gt; &quot;及格&quot; else -&gt; &quot;不及格&quot; &#125; println(&quot;$&#123;score&#125; = $&#123;str&#125;&quot;)&#125; 例子7 12345678910fun main(args: Array&lt;String&gt;) &#123; var inputPrice = &quot;09&quot; println(realPrice(inputPrice))&#125;fun realPrice(inputPrice:Any)=when(inputPrice)&#123; is String -&gt; inputPrice.toDouble()//如果inputPrice类型为String,返回该字符的Double值 is Int -&gt; inputPrice.toDouble()//如果inputPrice类型为Int,返回该字符的Double值 is Double -&gt; inputPrice else -&gt; 0.0&#125; 例子8 12345678910111213fun main(args: Array&lt;String&gt;) &#123; println(&quot;请输入内容&quot;) val string = readLine()//读取控制台的一行输入 类型: String? if(string!=null)&#123; when&#123; //每个分支条件都需要是布尔表达式 string.matches(Regex(&quot;\\d+&quot;)) -&gt; println(&quot;您输入的全是数字&quot;) string.matches(Regex(&quot;[a-zA-Z]+&quot;)) -&gt; println(&quot;您输入的全是字母&quot;) string.matches(Regex(&quot;[a-zA-Z0-9]+&quot;)) -&gt; println(&quot;您输入的既有数字也有字母&quot;) else -&gt; println(&quot;您输入的内容中包含了特殊字符&quot;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin练习 - if分支结构练习]]></title>
    <url>%2F2018%2F12%2F16%2Fkotlin%2Fkotlin%E7%BB%83%E4%B9%A0-if%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[kotlin练习 - if分支结构练习 if 分支 常见形式： 第一种形式 123if(expression)&#123; statements...&#125; 第二种形式 12345if(expression)&#123; statements...&#125;else&#123; statements...&#125; 第三种形式 123456if(expression)&#123; statements...&#125;else if(expression)&#123; statements...&#125;... //可以有零个或多个else判断 注意事项 通常建议不要省略if、else、else if后执行体的花括号{}，即使条件执行体只有一行代码，也要保留花括号，这样有更好的可读性，也可以避免发生错误的可能。 表达式 1var str = if (age&gt;20) &quot;age大于20&quot; else if (age&lt;20) &quot;age小于20&quot; else &quot;age等于20&quot; 123456789101112var age = 20var str = if (age &gt; 20) &#123; println(&quot;age大于20的分支&quot;) &quot;age大于20&quot;&#125; else if (age &lt; 20) &#123; println(&quot;age小于20的分支&quot;) &quot;age小于20&quot;&#125; else &#123; println(&quot;age等于20的分支&quot;) &quot;age等于20&quot;&#125;println(str)]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
